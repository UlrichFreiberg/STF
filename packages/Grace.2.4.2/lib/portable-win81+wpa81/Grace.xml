<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Grace</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:Grace.Data.ComplexObject">
            <summary>
            Intended to be used for modeling complex hierarchies of objects
            </summary>
        </member>
        <member name="T:Grace.Data.IComplexObject">
            <summary>
            Represents a complex data object usually a data model
            </summary>
        </member>
        <member name="M:Grace.Data.IComplexObject.SetParent(Grace.Data.IComplexObject,System.String,Grace.Data.ChildChangedHandler)">
            <summary>
            Set the owning parent of the object
            </summary>
            <param name="newParent">new parent</param>
            <param name="identityInParent">name inside parent</param>
            <param name="notifyUponchange">handler to be notified upon change</param>
            <returns>returns true if the parent was set</returns>
        </member>
        <member name="P:Grace.Data.IComplexObject.Parent">
            <summary>
            Parent of the object
            </summary>
        </member>
        <member name="P:Grace.Data.IComplexObject.IdentityInParent">
            <summary>
            Identity in the parent object (usually property name)
            </summary>
        </member>
        <member name="P:Grace.Data.IComplexObject.Children">
            <summary>
            Children of this complex object
            </summary>
        </member>
        <member name="P:Grace.Data.IComplexObject.IsDirty">
            <summary>
            Is the object dirty
            </summary>
        </member>
        <member name="E:Grace.Data.IComplexObject.DataChanged">
            <summary>
            Data Changed event
            </summary>
        </member>
        <member name="M:Grace.Data.ComplexObject.SetParent(Grace.Data.IComplexObject,System.String,Grace.Data.ChildChangedHandler)">
            <summary>
            Set the owning parent of the object
            </summary>
            <param name="newParent">new parent</param>
            <param name="identityInParent">name inside parent</param>
            <param name="notifyUponchange">handler to be notified upon change</param>
            <returns>
            returns true if the parent was set
            </returns>
            <exception cref="T:System.Exception">Object already has a parent. Remove frmo its previous heirarchy first.</exception>
        </member>
        <member name="M:Grace.Data.ComplexObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets the property.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="storage">The storage.</param>
            <param name="value">The value.</param>
            <param name="propertyName">Name of the property.</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.ComplexObject.ChildDataChange(Grace.Data.IComplexObject,Grace.Data.ComplexDataChangedArgs)">
            <summary>
            Child data change handler
            </summary>
            <param name="child">The child.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="P:Grace.Data.ComplexObject.Parent">
            <summary>
            Parent of the object
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexObject.IdentityInParent">
            <summary>
            Identity in the parent object (usually property name)
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexObject.Children">
            <summary>
            Children of this complex object
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexObject.IsDirty">
            <summary>
            Is the object dirty
            </summary>
        </member>
        <member name="E:Grace.Data.ComplexObject.DataChanged">
            <summary>
            Data Changed event
            </summary>
        </member>
        <member name="E:Grace.Data.ComplexObject.PropertyChanged">
            <summary>
            Occurs when [property changed].
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexObject.ChildrenList">
            <summary>
            Gets the children list.
            </summary>
            <value>
            The children list.
            </value>
        </member>
        <member name="T:Grace.Data.ComplexDataChangedArgs">
            <summary>
            Data change event inside complex object
            </summary>
        </member>
        <member name="M:Grace.Data.ComplexDataChangedArgs.#ctor(System.String,System.String)">
            <summary>
            Default Constructor
            </summary>
            <param name="identityInParent">identity in parent</param>
            <param name="propertyName">property name of change</param>
        </member>
        <member name="P:Grace.Data.ComplexDataChangedArgs.OriginalSender">
            <summary>
            Original object that sent the data change event
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexDataChangedArgs.FullPropertyName">
            <summary>
            Property path to the object that raised the event
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexDataChangedArgs.OldValue">
            <summary>
            Old object value
            </summary>
        </member>
        <member name="P:Grace.Data.ComplexDataChangedArgs.NewValue">
            <summary>
            New object value
            </summary>
        </member>
        <member name="T:Grace.Data.ChildChangedHandler">
            <summary>
            Delegate for handling Complex data changes
            </summary>
            <param name="complexObject"></param>
            <param name="args"></param>
        </member>
        <member name="T:Grace.Data.IComplexObjectExtensions">
            <summary>
            C# extensions for complex object
            </summary>
        </member>
        <member name="M:Grace.Data.IComplexObjectExtensions.ExecuteActionOnAll``1(Grace.Data.IComplexObject,System.Action{``0},System.Boolean)">
            <summary>
            Execute an action on all objects
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="complexObject">complex object</param>
            <param name="executeAction">action to execute</param>
            <param name="catchExceptions">catch all exceptions</param>
        </member>
        <member name="T:Grace.Data.IExtraDataContainer">
            <summary>
            Used to store extra data, implemented by IInjectionContext and IExportLocator
            </summary>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName">name of data object to get</param>
            <returns>data value</returns>
        </member>
        <member name="M:Grace.Data.IExtraDataContainer.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName">object name</param>
            <param name="newValue">new object value</param>
        </member>
        <member name="T:Grace.Data.Immutable.KeyExistsException`1">
            <summary>
            Key already exists in ImmutableHashTree
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.KeyExistsException`1.#ctor">
            <summary>
            Default constructor takes key
            </summary>
        </member>
        <member name="T:Grace.Data.IReflectionService">
            <summary>
            Simple service that allows the caller to access properties and call method on objects 
            the only have string names for.
            The Default implementation uses cached compiled Linq Expressions for performance reasons
            </summary>
        </member>
        <member name="M:Grace.Data.IReflectionService.GetPropertyValue(System.Object,System.String)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <returns>property value</returns>
        </member>
        <member name="M:Grace.Data.IReflectionService.GetPropertyValue(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <param name="index">index for final property</param>
            <param name="throwIfPathMissing">throw an exception if any part of the path is missing</param>
            <returns>property value</returns>
        </member>
        <member name="M:Grace.Data.IReflectionService.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.Data.IReflectionService.SetPropertyValue(System.Object,System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
            <param name="index"></param>
            <param name="createIfPathMissing"></param>
        </member>
        <member name="M:Grace.Data.IReflectionService.CallMethod(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Calls a method in the target by a specified name.
            For a method with a return type of void use T type of object
            </summary>
            <typeparam name="T">the return type of the method</typeparam>
            <param name="target">the target object</param>
            <param name="methodName">method name (can be dotted form A.B.C</param>
            <param name="throwIfPathMissing">throw an exception if part of the path is missing</param>
            <param name="parameters">parameters to the method</param>
            <returns>the value the method returns</returns>
        </member>
        <member name="M:Grace.Data.IReflectionService.CreateGetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that can be used to access a property in an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <returns>new property delegate</returns>
        </member>
        <member name="M:Grace.Data.IReflectionService.CreateSetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that be used to set a property on an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <returns>new property delegate</returns>
        </member>
        <member name="T:Grace.Data.NotifyObject">
            <summary>
            A base object that implements INotifyPropertyChanged and offers logging
            </summary>
        </member>
        <member name="M:Grace.Data.NotifyObject.SetProperty``1(``0@,``0,System.String)">
            <summary>
            Sets a value to a particular property while calling PropertyChanged
            Note: Default implementation from VS temlate
            </summary>
            <typeparam name="T">type of property</typeparam>
            <param name="storage">backing field for the property</param>
            <param name="value">new value to set</param>
            <param name="propertyName">property name (usually left blank if calling from property)</param>
            <returns>true if the value was set (false if its the same value)</returns>
        </member>
        <member name="M:Grace.Data.NotifyObject.OnPropertyChanged(System.String)">
            <summary>
            Default implementation of Propertychanged event invoker
            </summary>
            <param name="propertyName">property that changed</param>
        </member>
        <member name="P:Grace.Data.NotifyObject.Log">
            <summary>
            ILog instance for this class
            </summary>
        </member>
        <member name="E:Grace.Data.NotifyObject.PropertyChanged">
            <summary>
            Property change event
            </summary>
        </member>
        <member name="T:Grace.Data.ReflectionService">
            <summary>
            Service creates delegates that can be used to access properties off objects at runtime
            </summary>
        </member>
        <member name="M:Grace.Data.ReflectionService.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Grace.Data.ReflectionService.GetPropertyValue(System.Object,System.String)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <returns>property value</returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.GetPropertyValue(System.Object,System.String,System.Object,System.Boolean)">
            <summary>
            Gets a named property value from an object
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name (can be nested A.B.C.D)</param>
            <param name="index">index for final property</param>
            <param name="throwIfPathMissing">throw an exception if any part of the path is missing</param>
            <returns>property value</returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.Data.ReflectionService.SetPropertyValue(System.Object,System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            Sets a value into a named Property
            </summary>
            <param name="valueObject">target object</param>
            <param name="propertyName">property name to fetch</param>
            <param name="newValue"></param>
            <param name="index"></param>
            <param name="createIfPathMissing"></param>
        </member>
        <member name="M:Grace.Data.ReflectionService.CallMethod(System.Object,System.String,System.Boolean,System.Object[])">
            <summary>
            Calls a method in the target by a specified name.
            For a method with a return type of void use T type of object
            </summary>
            <typeparam name="T">the return type of the method</typeparam>
            <param name="target">the target object</param>
            <param name="methodName">method name (can be dotted form A.B.C</param>
            <param name="throwIfPathMissing">throw an exception if part of the path is missing</param>
            <param name="parameters">parameters to the method</param>
            <returns>the value the method returns</returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.CreateGetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that can be used to access a property in an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <returns>new property delegate</returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.CreateSetPropertyDelegate(System.Type,System.String,System.Type)">
            <summary>
            Creates a new delegate that be used to set a property on an object by property name
            </summary>
            <param name="instanceType">object type to target</param>
            <param name="propertyName">property name (can be dotted form A.B.C)</param>
            <param name="indexType">type of property used for indexing</param>
            <returns>new property delegate</returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.GetPropertyInfo(System.Type,System.String)">
            <summary>
            Gets property info for a dotted property
            </summary>
            <param name="baseType">type</param>
            <param name="propertyString">property string</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.ReflectionService.CheckTypeIsBasedOnAnotherType(System.Type,System.Type)">
            <summary>
            Checks to see if checkType is based on baseType
            Both inheritance and interface implementation is considered
            </summary>
            <param name="checkType">check type</param>
            <param name="baseType">base type</param>
            <returns>true if check type is base type</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ActivationCompleteAttribute">
            <summary>
            Methods that are attributed with this class will be called at the end of activation
            Note: the signature must be Action() or Action(IInjectionContext)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IActivationCompleteAttribute">
            <summary>
            Attibutes that implement this interface will be discovered during scanning
            It is to be used on methods that are to be called during activation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.AfterConstructionAttribute">
            <summary>
            Properties that are marked with this attribute will be imported after construction
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportAfterConstructionAttribute">
            <summary>
            Attributes that implement this interface will be used to figure out if the property should be done after construction
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportAfterConstructionAttribute.ImportAfterConstruction(System.Type,System.Type)">
            <summary>
            Should import after construction
            </summary>
            <param name="activationType">type being activated</param>
            <param name="propertyType">property type</param>
            <returns>should import after</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.AfterConstructionAttribute.ImportAfterConstruction(System.Type,System.Type)">
            <summary>
            Import after construction
            </summary>
            <param name="activationType"></param>
            <param name="propertyType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.DesignTimeOnlyAttribute">
            <summary>
            Attributed classes will only be used during design time
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery time
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportEnvironmentAttribute.ProvideEnvironment(System.Type)">
            <summary>
            Provide the environment for the specified type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export environment</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportAttribute">
            <summary>
            This attribute is used to mark a type for export. 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute">
            <summary>
            Attributes that implement this interface will be included while scanning for exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor">
            <summary>
            Default constructor. Export as the class name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.String,System.String[])">
            <summary>
            exports using the provided export name
            </summary>
            <param name="exportName"></param>
            <param name="extraNames"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.#ctor(System.Type,System.Type[])">
            <summary>
            Export by type rather than by name
            </summary>
            <param name="exportType"></param>
            <param name="extraTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provide a list of export names that the type should be exported as
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provide a list of types to export as
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportNames">
            <summary>
            The list of export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ExportAttribute.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportByClassNameAttribute">
            <summary>
            Exports a class by it's name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByClassNameAttribute.ProvideExportNames(System.Type)">
            <summary>
            Exports a class by name
            </summary>
            <param name="attributedType">class to export</param>
            <returns>list of export names</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByClassNameAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Exports a class by type
            </summary>
            <param name="attributedType">class to be exported</param>
            <returns>list of types to export by</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute">
            <summary>
            Classes that have this attribute will be exported by the interfaces it implements
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute.ProvideExportNames(System.Type)">
            <summary>
            Provides a list of export name
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportByInterfacesAttribute.ProvideExportTypes(System.Type)">
            <summary>
            Provides a list of export types (i.e. implemented interfaces)
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportEnvironmentAttribute">
            <summary>
            Exports under in an Environment
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportEnvironmentAttribute.#ctor(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Default constructor
            </summary>
            <param name="environment">export environment</param>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportKeyAttribute">
            <summary>
            Adds a key to an exported class
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportKeyAttribute">
            <summary>
            Attributes that implement this interface will be used to provide an export key
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportKeyAttribute.ProvideKey(System.Type)">
            <summary>
            Provide an export key
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export key</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportKeyAttribute.#ctor(System.Object)">
            <summary>
            Default constructor
            </summary>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportKeyAttribute.ProvideKey(System.Type)">
            <summary>
            Provide key
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>export key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportPriorityAttribute">
            <summary>
            This attribute can be used to control the priority for the export
            Note: ranked high to low
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute">
            <summary>
            Attributes that implement this interface will be called during discover to provide a priority
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide the priority for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Export priority cosntructor
            </summary>
            <param name="priority">priority for export, ranked high to low</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportPriorityAttribute.ProvidePriority(System.Type)">
            <summary>
            Provide a priority value
            </summary>
            <param name="attributedType">type that was attributed</param>
            <returns>priority value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute">
            <summary>
            Limits an export to only be used when the class it's being injected into has the specified attribute
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute">
            <summary>
            Attributes that implement this interface can provide a condition for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportConditionAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes an attribute type to filter on
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a condition for the type provided
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute">
            <summary>
            Applies an condition on the export where it will be injected into specified types and only those types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor takes list of injected types
            </summary>
            <param name="injectedTypes">types that this export can be used in</param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ExportWhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide a new WhenInjectedInto condition
            </summary>
            <param name="exportType">attributed type</param>
            <returns>new condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute">
            <summary>
            Attributes that implement this interface will be included while discovering attributes for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.ImportName">
            <summary>
            Import name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttributedWithAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.InNewContextAttribute">
            <summary>
            Classes marked with this attribute will be constructed in a new context
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IInNewContextAttribute">
            <summary>
            Interfaces that implement this intreface will be used to mark the export in new context
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ICustomEnrichmentExpressionAttribute">
            <summary>
            Attributed that implement this interface will be used to enrich the delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.ICustomEnrichmentExpressionAttribute.GetProvider(System.Type,System.Object)">
            <summary>
            Get a custom enrichment provider, you are given the attributed type and possible attributed member
            </summary>
            <param name="attributedType">attributed type</param>
            <param name="attributedMember">PropertyInfo or MethodInfo that was attributed, can be null if the class was attributed</param>
            <returns>custom linq expression provider</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ICustomInitializationAttribute">
            <summary>
            Attributes that implement this inteface will be used during discovery
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute">
            <summary>
            Attributes that implement will be called at discovery time to provide an EnrichWithDelegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IEnrichWithAttribute.ProvideDelegate(System.Type)">
            <summary>
            Provides an EnrichWithDelegate for an attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute">
            <summary>
            Attributes that implement this interface will be called during discovery to provide metadata for an attributed type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportMetadataAttribute.ProvideMetadata(System.Type)">
            <summary>
            Provide the metadata for an attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns>a named piece of metadata</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute">
            <summary>
            Attributes that implement this interface will be called at discovery time to provide an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IExportStrategyProviderAttribute.ProvideStrategy(System.Type)">
            <summary>
            Provide an export strategy for the attributed type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo">
            <summary>
            Information about how the import should be performed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportName">
            <summary>
            The name of the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ImportKey">
            <summary>
            The key that should be used when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ValueProvider">
            <summary>
            Value provider to use instead of looking up value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.ExportStrategyFilter">
            <summary>
            Import Filter 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.Interfaces.ImportAttributeInfo.Comparer">
            <summary>
            Comparer object for import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportFilterAttribute">
            <summary>
            Attributes that implement this interface can be used to filter an import
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportFilterAttribute.ProvideFilter(System.Type,System.String)">
            <summary>
            Provide a filter to be used when importing
            </summary>
            <param name="attributedType">attributed type</param>
            <param name="attributedName">attributed name</param>
            <returns>new filter</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportSortCollectionAttribute">
            <summary>
            This interface allows the developer to create a custom attribute that provides an IComparer(T) object to be used to sor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportSortCollectionAttribute.ProvideComparer(System.Type,System.String)">
            <summary>
            Provides an IComparer(T) 
            </summary>
            <param name="attributedType"></param>
            <param name="attributedName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute">
            <summary>
            Import attributes that implement this attribute can be used to import a particular value provider into 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.IImportValueProviderAttribute.ProvideProvider(System.Type)">
            <summary>
            Provide an IExportValueProvider to be used on import
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute">
            <summary>
            Attributes that implement this interface will be queried during discovery to provide a life cycle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.Interfaces.ILifestyleProviderAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.ImportAttribute">
            <summary>
            This attribute can be used to attribute properties, methods, constructors or parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.ImportAttribute.ProvideImportInfo(System.Type,System.String)">
            <summary>
            Provides information about the import
            </summary>
            <param name="attributedType">the type that is attributed, null when attributed on methods</param>
            <param name="attributedName">the name of the method, property, or parameter name</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Name">
            <summary>
            Name to use when importing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Key">
            <summary>
            Key to use when importing 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Attributes.ImportAttribute.Required">
            <summary>
            Is this import required. True by default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonAttribute">
            <summary>
            Exports attribute with this attribute will be shared as a single instance for all scopes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute">
            <summary>
            Exports marked with this attribute will be shared per injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerInjectionContextAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute">
            <summary>
            Exports that are marked with this attribute will be shared per request.
            Note: request has different meanings in different contexts.
            WCF - limited to per WCF operation
            MVC - Per HTTP Request
            Other - without a context the export will be shared for the injection context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerRequestAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute">
            <summary>
            Exports marked with this attribute will be shared per scope.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.SingletonPerScopeAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WeakSingletonAttribute">
            <summary>
            Exports attributed with this will be shared, the instance will be held with a weak reference so it will be GC'd when done
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WeakSingletonAttribute.ProvideLifestyle(System.Type)">
            <summary>
            Provide a Lifestyle container for the attributed type
            </summary>
            <param name="attributedType">attributed type</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenClassHasAttribute">
            <summary>
            Export condition that limits the export to only be used in classes that have a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenClassHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provides a new WhenClassHas condition
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute">
            <summary>
            Limits an export to only be used when being injected into one of the types
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenInjectedIntoAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute">
            <summary>
            Limits an export to only be used when the importing member has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenMemberHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute">
            <summary>
            Limits an export to only be used when the target has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.#ctor(System.Type)">
            <summary>
            Default constructor that takes attribute type
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Attributes.WhenTargetHasAttribute.ProvideCondition(System.Type)">
            <summary>
            Provide an export condition for an attirbuted type
            </summary>
            <param name="attributedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.IExportCondition">
            <summary>
            any class that implements this interface can be used as a condition on an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.IExportCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.MultipleConditions">
            <summary>
            Combines multiple conditions into one
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.#ctor(Grace.DependencyInjection.Conditions.IExportCondition[])">
            <summary>
            Default Constructor
            </summary>
            <param name="exportConditions"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.MultipleConditions.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.UnlessCondition">
            <summary>
            Simple condition that exports unless the condition is meet
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.UnlessCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenAncestor">
            <summary>
            When ancestor is of certain type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenAncestor.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="ancestorTypes">ancestor types</param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenAncestor.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Condition meet
            </summary>
            <param name="scope">injection scope</param>
            <param name="injectionContext">injection context</param>
            <param name="exportStrategy">export strategy</param>
            <returns>condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenCondition">
            <summary>
            Simple condition true when delegate returns true
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.#ctor(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenCondition.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached">
            <summary>
            Export condition that limits the export to only be used when the debugger is attached
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true when the debugger is attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached">
            <summary>
            Export condition that limits the export to only be used when there is no debugger
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenDebuggerIsNotAttached.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Returns true only when there is no debugger attached
            </summary>
            <param name="scope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenInjectedInto">
            <summary>
            Export condition that is true when being injected into
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.#ctor(System.Type[])">
            <summary>
            Default constructor
            </summary>
            <param name="injectedType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenInjectedInto.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenClassHas">
            <summary>
            Export condition that is true when class has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenClassHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenMemberHas">
            <summary>
            Export condition that is true when the member (Constructor,Method or Property) has a particular attribute
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenMemberHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Conditions.WhenTargetHas">
            <summary>
            Export condition that is true when target has a particular attribute on it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="attributeType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Conditions.WhenTargetHas.ConditionMeet(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Called to determine if the export strategy meets the condition to be activated
            </summary>
            <param name="scope">injection scope that this export exists in</param>
            <param name="injectionContext">injection context for this request</param>
            <param name="exportStrategy">export strategy being tested</param>
            <returns>true if the export meets the condition</returns>
        </member>
        <member name="T:Grace.DependencyInjection.CurrentInjectionInfo">
            <summary>
            Information of the object being injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.CurrentInjectionInfo.#ctor(System.Type,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="activationType">type being exported</param>
            <param name="currentExportStrategy">strategy being injected</param>
        </member>
        <member name="P:Grace.DependencyInjection.CurrentInjectionInfo.ActivationType">
            <summary>
            Type being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.CurrentInjectionInfo.CurrentExportStrategy">
            <summary>
            Current injection strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.CurrentInjectionInfo.UniqueId">
            <summary>
            Provides a unique id for this instance
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportActivationDelegate">
            <summary>
            Delegate representing scope in wich this export is being activated
            </summary>
            <param name="injectionScope">scope that the export startegy is attached to, this can be different than it's owning scope</param>
            <param name="context">context for the injection</param>
            <returns>new activated object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Used to filter out exports
            </summary>
            <param name="context">context to use during filtering</param>
            <param name="strategy">strategy to filter</param>
            <returns>return true if the strategy should be used</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyComparer">
            <summary>
            Used to compare two exports within a particular export environment
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="exportEnvironment">current environment</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportRegistrationDelegate">
            <summary>
            This delegate allows you to provide extra registration during scope creation
            </summary>
            <param name="registration">registration object</param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportFunction`1">
            <summary>
            This delegate can be used to provide an export
            </summary>
            <typeparam name="T">type being returned</typeparam>
            <param name="injectionScope">injection scope</param>
            <param name="injectionContext">injection context</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.EnrichWithDelegate">
            <summary>
            Using this delegate you can provide custom logic to the activation process overriding 
            </summary>
            <param name="scope">injection scope for this export</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="injectedObject">injected object</param>
            <returns>return the initial object or return a wrapping object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.BeforeDisposalCleanupDelegate">
            <summary>
            This delegate allows the developer to perform some cleanup before Dispose is called
            </summary>
            <param name="objectBeingDisposed"></param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportConditionDelegate">
            <summary>
            Delegate is used to figure out if the export strategy meets the proper condition
            </summary>
            <param name="scope">scope the export is in</param>
            <param name="injectionContext">injection context for this call</param>
            <param name="exportStrategy">export strategy being considered</param>
            <returns>return true if the export is to be considered</returns>
        </member>
        <member name="T:Grace.DependencyInjection.KeyedLocateDelegate`2">
            <summary>
            This delegate will locate an export using a Key
            </summary>
            <typeparam name="TKey">key type to locate with</typeparam>
            <typeparam name="TValue">value type to locate</typeparam>
            <param name="key">key to locate with</param>
            <returns>located value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.DisposableInjectionContext">
            <summary>
            Disposable injection contexts can be used to resolve disposable object in scope
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.InjectionContext">
            <summary>
            Default implementation of IInjectionContext
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContext">
            <summary>
            There is one new Injection context object created for each injection request.
            It holds information pertinent to this injection
            Note: The implementation for IInjectionContext is not thread safe
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Clone">
            <summary>
            Creates a clone of the injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate(System.Type)">
            <summary>
            Locate an export by type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export(System.Type,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Export a type with an activation delegate
            </summary>
            <param name="exportType"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.Export(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.PushCurrentInjectionInfo``1(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Push a current export strategy onto the stack
            </summary>
            <param name="exportStrategy">export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.PopCurrentInjectionInfo">
            <summary>
            Pop the current export strategy off the stack
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContext.GetInjectionStack">
            <summary>
            Injection info all the way up the stack
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.DisposalScope">
            <summary>
            The disposal scope associated with this injection request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.TargetInfo">
            <summary>
            The target information for the current injection, 
            specifically what is the type you are being injected into and what is the PropertyInfo or ParameterInfo being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.Instance">
            <summary>
            When importing a property after construction this will contain the instance that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Constructor that uses requesting scope as disposal scope
            </summary>
            <param name="requestingScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.#ctor(Grace.DependencyInjection.IDisposalScope,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="disposalScope"></param>
            <param name="requestingScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetEnumerator">
            <summary>
            Returns an enumeration of exports
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumation of exports
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Clone">
            <summary>
            Clone the context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate``1">
            <summary>
            Locate an export by type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate(System.Type)">
            <summary>
            Locate an export by type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Locate(System.String)">
            <summary>
            Locate an export by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export by type for this injection context
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export(System.Type,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Export by type
            </summary>
            <param name="exportType"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Export(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Register an export by name for this injection context
            </summary>
            <param name="name"></param>
            <param name="activationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.PushCurrentInjectionInfo``1(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Push a current export strategy onto the stack
            </summary>
            <param name="exportStrategy">export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.PopCurrentInjectionInfo">
            <summary>
            Pop the current export strategy off the stack
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.GetInjectionStack">
            <summary>
            Injection info all the way up the stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.Object)">
            <summary>
            Add a new object to injection context for export
            </summary>
            <param name="export"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Add a new Type to injection context for export
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.String,System.Object)">
            <summary>
            Adds a new export by name to the injection context
            </summary>
            <param name="name">export name</param>
            <param name="value">export value</param>
        </member>
        <member name="M:Grace.DependencyInjection.InjectionContext.Add(System.String,Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Adds a new export by name to the injection context
            </summary>
            <param name="name">export name</param>
            <param name="activationDelegate">activation delegate</param>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.DisposalScope">
            <summary>
            Disposal scope for the injection context
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.RequestingScope">
            <summary>
            The scope that the request originated in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.TargetInfo">
            <summary>
            The target information for the current injection
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.Instance">
            <summary>
            When importing a property after construction this will contain the instance that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.InjectionContext.MaxResolveDepth">
            <summary>
            Max resolve depth allowed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DisposableInjectionContext.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="requestingScope">requesting scope</param>
        </member>
        <member name="M:Grace.DependencyInjection.DisposableInjectionContext.Dispose">
            <summary>
            Dispose of the context
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportEnvironment">
            <summary>
            Defined what environement the application is running in or compenent is Exported in
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.Any">
            <summary>
            Can be used in any environment
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTime">
            <summary>
            Best used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.RunTimeOnly">
            <summary>
            Can only be used at runtime
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTime">
            <summary>
            Best used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.DesignTimeOnly">
            <summary>
            Only used at design time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTest">
            <summary>
            Best used at unit test time
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportEnvironment.UnitTestOnly">
            <summary>
            Only used at unit test time
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.CircularDependencyDetectedException">
            <summary>
            This exception is thrown when a loop is detected trying to resolve an export.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.LocateException">
            <summary>
            Base exception for all exception that can be generated by Locate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default Constructor takes the locating type and the current injection context
            </summary>
            <param name="locateName">the name used when locating</param>
            <param name="locatingType">the type used when locating</param>
            <param name="currentContext">the current context when the exception was generated</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,System.Exception)">
            <summary>
            Constructor that takes inner exception
            </summary>
            <param name="locateName">locate name</param>
            <param name="locatingType">locate type</param>
            <param name="currentContext">injection context</param>
            <param name="innerException">inner exception</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.AddLocationInformationEntry(Grace.DependencyInjection.Exceptions.ILocationInformationEntry)">
            <summary>
            Adds a new location information entry
            </summary>
            <param name="entry">new entry</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocateException.CreateMessageFromLocationInformation(System.Text.StringBuilder)">
            <summary>
            Creates a numbered exception message from the location information
            </summary>
            <param name="stringBuilder"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.LocatingType">
            <summary>
            Type that is being located, this can be null when locating something by name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.OwningType">
            <summary>
            This is the type that has the dependency on LocateType
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.InjectionContext">
            <summary>
            Injection context for exception
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.LocateName">
            <summary>
            The named that was used during location, this can be null when locating by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.LocationInformation">
            <summary>
            Location Information for this exception
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocateException.LocateDisplayString">
            <summary>
            Display string to be used for error messages
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.CircularDependencyDetectedException.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default constructor
            </summary>
            <param name="locateName">locate name</param>
            <param name="locatingType">locate type</param>
            <param name="currentContext">injection context</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.CircularDependencyDetectedException.#ctor(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default constructor
            </summary>
            <param name="locateName">locate name</param>
            <param name="locatingType">locate type</param>
            <param name="currentContext">injection context</param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.CircularDependencyDetectedException.Message">
            <summary>
            Message for the exception
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.GeneralLocateException">
            <summary>
            This is a General catch all exception that normally wraps another exception throw while 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.GeneralLocateException.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionContext,System.Exception)">
            <summary>
            Default constructor takes information about what was happening at the moment the exception was caught
            </summary>
            <param name="locateName">name to use when locating</param>
            <param name="locatingType">type used when locating</param>
            <param name="currentContext">current context</param>
            <param name="innerException">inner exception</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.GeneralLocateException.#ctor(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext,System.Exception)">
            <summary>
            Default constructor takes information about what was happening at the moment the exception was caught
            </summary>
            <param name="locateName">name to use when locating</param>
            <param name="locatingType">type used when locating</param>
            <param name="currentContext">current context</param>
            <param name="innerException">inner exception</param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.GeneralLocateException.Message">
            <summary>
            Message
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.InjectionScopeCouldNotBeFoundException">
            <summary>
            This exception is thrown when an injection scope by the specified name couldn't be found
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.StrategyBeingActivated">
            <summary>
            Information about a strategy being activated
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.StrategyBeingActivated.#ctor(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="exportStrategy">strategy being activated</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.StrategyBeingActivated.CreateMessage(System.Text.StringBuilder)">
            <summary>
            Create message
            </summary>
            <param name="stringBuilder">string builder</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.StrategyBeingActivated.ToString">
            <summary>
            To String
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.InjectionScopeLocateEntry">
            <summary>
            Information about a locate call
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.InjectionScopeLocateEntry.#ctor(System.String,System.Type,System.String,System.Boolean,System.Boolean)">
            <summary>
            Default constructor
            </summary>
            <param name="locateName">name being located</param>
            <param name="locateType">type being located</param>
            <param name="scopeName">name of scope</param>
            <param name="hasFilter">has filter</param>
            <param name="locateMultiple">locate multiple</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.InjectionScopeLocateEntry.CreateMessage(System.Text.StringBuilder)">
            <summary>
            Create an error message
            </summary>
            <param name="stringBuilder">string builder for message</param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.InjectionScopeLocateEntry.ToString">
            <summary>
            To String
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.LocationInformationEntry">
            <summary>
            Location Information
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocationInformationEntry.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionTargetInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="locateName">name used to locate</param>
            <param name="locateType">type used to locate</param>
            <param name="targetInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocationInformationEntry.#ctor(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionTargetInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="locateName">name used to locate</param>
            <param name="locateType">type used to locate</param>
            <param name="targetInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocationInformationEntry.CreateMessage(System.Text.StringBuilder)">
            <summary>
            Create message
            </summary>
            <param name="stringBuilder"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.LocationInformationEntry.ToString">
            <summary>
            To String
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocationInformationEntry.TargetInfo">
            <summary>
            Target Info
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocationInformationEntry.LocateName">
            <summary>
            Locate Name used when locating
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.LocationInformationEntry.LocateType">
            <summary>
            Type used when locating
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.MissingDependencyException">
            <summary>
            Exception thrown when there is a missing dependency for an export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.MissingDependencyException.#ctor(System.String,System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default Constructor
            </summary>
            <param name="locateName"></param>
            <param name="locatingType"></param>
            <param name="currentContext"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.MissingDependencyException.#ctor(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default Constructor
            </summary>
            <param name="locateName"></param>
            <param name="locatingType"></param>
            <param name="currentContext"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.MissingDependencyException.Message">
            <summary>
            Exception message
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.PublicConstructorNotFoundException">
            <summary>
            Exception is thrown when an exported type does not have a public constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.PublicConstructorNotFoundException.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="T:Grace.DependencyInjection.ExportsThat">
            <summary>
            static class that provides ExportStrategyFilter methods to be used during export registration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveMetadata(System.String,System.Object)">
            <summary>
            Filters exports down to ones that have particular metadata
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value optional</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Provide a Type filter for the exports attribute
            </summary>
            <param name="consider">type filter (TypesThat will work here)</param>
            <returns>export configuration</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.Activate(System.Func{System.Type,System.Boolean})">
            <summary>
            Matches exports that activate a particular type
            </summary>
            <param name="activateTypeFilter">type filter (TypesThat will work here)</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreExportedAs``1">
            <summary>
            Creates a new Filter that selects only exports that export as a specific interface
            </summary>
            <typeparam name="T">export type</typeparam>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreExportedAs(System.Type)">
            <summary>
            Creates a new Filter that selects only exports that export as a specific interface
            </summary>
            <param name="exportType">export type</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreExportedAs(System.Func{System.Type,System.Boolean})">
            <summary>
            Provide a filter that will loop through the list of export types for an export strategy
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreExportedAsName(System.String)">
            <summary>
            
            </summary>
            <param name="exportName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.AreExportedAsName(System.Func{System.String,System.Boolean})">
            <summary>
            
            </summary>
            <param name="exportNameFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportsThat.Match(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Creates a new filter that returns true when the provided filter matches
            </summary>
            <param name="exportFilter">export filter</param>
            <returns>export configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyDependencyType">
            <summary>
            Represents the type of dependency for the export
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.ConstructorParameter">
            <summary>
            A constructor parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.Property">
            <summary>
            A Property
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.ExportStrategyDependencyType.MethodParameter">
            <summary>
            A method parameter
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyDependency">
            <summary>
            Export strategy dependency
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.DependencyType">
            <summary>
            Type of dependency
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.TargetName">
            <summary>
            Name of the target being injected (ParameterName or PropertyName)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.ImportType">
            <summary>
            Type being imported, can be null when locating by name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.ImportName">
            <summary>
            name of export, can be null when locating by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.HasValueProvider">
            <summary>
            Has Value Provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyDependency.HasFilter">
            <summary>
            Has a filter for it's dependency
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ExportStrategyFilterGroup">
            <summary>
            A collection of export filters that can convert to one ExportStrategyFilter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.#ctor(Grace.DependencyInjection.ExportStrategyFilter[])">
            <summary>
            Default Constructor
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.op_Implicit(Grace.DependencyInjection.ExportStrategyFilterGroup)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts export filter group to export strategy filter
            </summary>
            <param name="exportStrategyGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ExportStrategyFilterGroup.InternalExportStrategyFilter(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Internal filter method that loops through the collection of filters
            </summary>
            <param name="context">injection context</param>
            <param name="strategy">export strategy</param>
            <returns>true if the strategy matches</returns>
        </member>
        <member name="P:Grace.DependencyInjection.ExportStrategyFilterGroup.UseOr">
            <summary>
            Use Or logic instead of and logic
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext">
            <summary>
            Provides a mechanism for requesting an Expression that will import a specified type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.AddLocalVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Parameters added usingt his method will be added to the main body of the delegate
            </summary>
            <param name="newLocalVariable">new local variable</param>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.GetConstructorExpression(System.Reflection.ConstructorInfo@,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression}@)">
            <summary>
            Creates the default Constructor Expression
            </summary>
            <param name="constructorInfo"></param>
            <param name="constructorParameters"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.GetLocateDependencyExpression(System.Type,System.String,Grace.DependencyInjection.IInjectionTargetInfo,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter,Grace.DependencyInjection.ILocateKeyValueProvider,System.Object)">
            <summary>
            Creates a Locate expression to be used in custom construction
            </summary>
            <param name="importType"></param>
            <param name="targetInfo"></param>
            <param name="importName"></param>
            <param name="variableName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <param name="comparerObject"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.ActivationType">
            <summary>
            Type being constructed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.ExportStrategyScopeParameter">
            <summary>
            The IInjectionScope this strategy is being call with
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.InjectionContextParameter">
            <summary>
            Injection context parameter (IInjectionContext)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext.InstanceVariable">
            <summary>
            Instance being created (object)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionProvider">
            <summary>
            Implementing this interface allows you to provide a set of Expressions that will be used to construct the type
            This is to override the default construction behavior
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionProvider.ProvideConstructorExpressions(Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionContext)">
            <summary>
            Provide a set of Expressions that will be used to construct the export.
            </summary>
            <param name="context">context that contains certain parameters</param>
            <returns>expressions</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext">
            <summary>
            Provides information about the expression being constructed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext.AddLocalVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Parameters added usingt his method will be added to the main body of the delegate
            </summary>
            <param name="newLocalVariable">new local variable</param>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext.ActivationType">
            <summary>
            Type being constructed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext.ExportStrategyScopeParameter">
            <summary>
            The IInjectionScope this strategy is being call with
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext.InjectionContextParameter">
            <summary>
            Injection context parameter (IInjectionContext)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext.InstanceVariable">
            <summary>
            Instance being created (object)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider">
            <summary>
            Classes the implement this interface can be used to enrich the Linq expression that the DI container creates for an export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider.ProvideExpressions(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionContext)">
            <summary>
            Provide a list of linq expressions that will be added to the Linq expression tree
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration">
            <summary>
            Allows for the configuration of a constructor param
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfiguration">
            <summary>
            Allows you to configure an assembly for export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndCondition(System.Func{System.Type,Grace.DependencyInjection.Conditions.IExportCondition})">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionFunc">condition for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <param name="baseType">base type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.BasedOn``1">
            <summary>
            Export all types based on speficied type by Type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterface``1">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="whereClause">where clause to test if the interface should be used for exporting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByType(System.Func{System.Type,System.Type})">
            <summary>
            Export the selected classes by type
            </summary>
            <param name="typeDelegate">type delegate to pick what type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Exports by a set of types
            </summary>
            <param name="typeDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByKeyedTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Tuple{System.Type,System.Object}}})">
            <summary>
            Export a type by a set of keyed types
            </summary>
            <param name="keyedDelegate">keyed types</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ByName(System.Func{System.Type,System.String})">
            <summary>
            Export by a particular name 
            </summary>
            <param name="nameDelegate">delegate used to create export name, default is type => type.Name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Enrich all with a particular delegate
            </summary>
            <param name="enrichWithDelegate">enrichment delegate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.EnrichWith(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.EnrichWithDelegate}})">
            <summary>
            Enrich all with a particular delegate
            </summary>
            <param name="enrichWithDelegates">enrichment delegates, IEnumerable must not be null</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Enrich all with linq expressions
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.EnrichWithExpression(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider}})">
            <summary>
            Enrich all with linq expressions
            </summary>
            <param name="providers">expression provider, IEnumerable must not be null</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude">exclude delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ExternallyOwned">
            <summary>
            Mark the exports to be externally owned, stopping the container from calling the Dispose
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ImportProperty``1">
            <summary>
            Import properties of type TProperty and by name
            </summary>
            <typeparam name="TProperty">property type</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.ImportProperty(System.Type)">
            <summary>
            Import all properties that match the type
            </summary>
            <param name="propertyType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause">where clause</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">condition delegate</param>
            /// <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life style
            </summary>
            <param name="container">lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.UsingLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ILifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">when condition</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <typeparam name="TParam">constructor param type</typeparam>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <typeparam name="TParam">constructor param type</typeparam>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <param name="paramType">constructor parameter type</param>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithKey(System.Func{System.Type,System.Object})">
            <summary>
            Provide a func that will be used to create a key that will be used to register
            </summary>
            <param name="withKeyFunc">key func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life style
            </summary>
            <param name="container">lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ILifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithPriority(System.Func{System.Type,System.Int32})">
            <summary>
            Set priority based on a func
            </summary>
            <param name="priorityFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithPriorityAttribute``1">
            <summary>
            Allows you to specify an attribute that will be used to apply 
            </summary>
            <typeparam name="T"></typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfiguration.WithInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Inspectors will be called for every export strategy that is found
            </summary>
            <param name="inspector">inspector object</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IExportTypeSetConfiguration.Lifestyle">
            <summary>
            Assign a lifestyle to all exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.Consider(System.Func{System.Type,Grace.DependencyInjection.ExportStrategyFilter})">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filterFunc">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.ImportName(System.Func{System.Type,System.String})">
            <summary>
            Name to use when resolving parameter
            </summary>
            <param name="importNameFunc"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.IsRequired(System.Func{System.Type,System.Boolean})">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequiredFunc">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.LocateWithKey(System.Func{System.Type,System.Object})">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateWithKeyFunc">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.LocateWithKeyProvider(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type,System.Object})">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateWithKeyFunc">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.LocateWithKeyProvider(Grace.DependencyInjection.ILocateKeyValueProvider)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKeyValueProvider">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.Named(System.Func{System.Type,System.String})">
            <summary>
            Name of the parameter to resolve
            </summary>
            <param name="namedFunc"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetCtorParamConfiguration.UsingValueProvider(System.Func{System.Type,Grace.DependencyInjection.IExportValueProvider})">
            <summary>
            Provides a value for a constructor parameter
            </summary>
            <param name="valueProviderFunc">value provider for parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionContextExtensions">
            <summary>
            Extensions for IInjectionContext
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContextExtensions.LocateFromRequestingScope``1(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locates a type from requesting scope of the specified injection context
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="injectionContext">injection context</param>
            <returns>located value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionContextExtensions.LocateFromRequestingScope(Grace.DependencyInjection.IInjectionContext,System.Type)">
            <summary>
            Locates a type from requesting scope of the specified injection context
            </summary>
            <param name="injectionContext">injection context</param>
            <param name="type">type to locate</param>
            <returns>located type</returns>
        </member>
        <member name="T:Grace.DependencyInjection.ILocateKeyValueProvider">
            <summary>
            Classes implementing this interface can be used to provide a key at locate time
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ILocateKeyValueProvider.ProvideValue(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type)">
            <summary>
            Provide locate key
            </summary>
            <param name="injectionScope">current injection scope</param>
            <param name="context">current locate context</param>
            <param name="activationType">type being activated</param>
            <returns>locate key</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IMissingExportStrategyProvider">
            <summary>
            Classes that implement this interface can be used to provide missing export strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IMissingExportStrategyProvider.ProvideExports(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Provide a list of exports that can be used to satisfy the request import.
            Note the exports will be tested used from first to last looking for the first matching export
            </summary>
            <param name="requestContext">requesting context</param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <returns>list of exports</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1">
            <summary>
            Base abstract export strategy that is 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategy">
            <summary>
            Classes that implement this interface can be used to export a particular type
            Note: All implementations of ExportStrategy should be thread safe. 
            It is expected that N number callers can activate at the same time.
            It's also recommended that the strategy me as immutable as possible
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportValueProvider">
            <summary>
            Classes that implement this interface can be used to provide an import value during construction
            
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportValueProvider.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export filter</param>
            <param name="locateKey"></param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext">injection context</param>
            <returns>true if the export should be used</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns>a list of strategies this export exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate">delegate called during activation</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Dispose">
            <summary>
            Dispose the Export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.SecondaryStrategies">
            <summary>
            No secondary strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            No enrichment
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.InnerType">
            <summary>
            Inner Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.DependsOn">
            <summary>
            no dependencies
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseIEnumerableExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration">
            <summary>
            Exports a set of types based on a provided configuration
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration">
            <summary>
            Configuration object 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.Named(System.String)">
            <summary>
            Property Name to import
            </summary>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.IsRequired(System.Boolean)">
            <summary>
            Is it required
            </summary>
            <param name="value">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Apply delegate to choose export
            </summary>
            <param name="consider">consider filter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.UsingValue(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Using Value provider
            </summary>
            <param name="activationDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Use value provider
            </summary>
            <param name="valueProvider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.AfterConstruction">
            <summary>
            Import the property after the instance has been constructed.
            The Instance property on IInjectionContext will be populated
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.OnlyOn(System.Func{System.Type,System.Boolean})">
            <summary>
            Only import on certain types
            </summary>
            <param name="filter">type filter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetImportPropertyConfiguration.Matching(System.Func{System.Reflection.PropertyInfo,System.Boolean})">
            <summary>
            Import only properties that match the filter
            </summary>
            <param name="matchingFilter">matching filter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategyProvider">
            <summary>
            Used by classes that provide strategies to the registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <typeparam name="TParam">constructor param type</typeparam>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <typeparam name="TParam">constructor param type</typeparam>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Adds a constructor param to exported types
            </summary>
            <param name="paramType">constructor parameter type</param>
            <param name="paramFunc">func to create constructor param</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#Consider(System.Func{System.Type,Grace.DependencyInjection.ExportStrategyFilter})">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filterFunc">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#ImportName(System.Func{System.Type,System.String})">
            <summary>
            Name to use when resolving parameter
            </summary>
            <param name="importNameFunc"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#IsRequired(System.Func{System.Type,System.Boolean})">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequiredFunc">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#LocateWithKey(System.Func{System.Type,System.Object})">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateWithKeyFunc">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.LocateWithKeyProvider(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type,System.Object})">
            <summary>
            Locate with a key provider func
            </summary>
            <param name="locateWithKeyFunc">locate func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.LocateWithKeyProvider(Grace.DependencyInjection.ILocateKeyValueProvider)">
            <summary>
            Locate with a key provider
            </summary>
            <param name="locateKeyValueProvider">key provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#Named(System.Func{System.Type,System.String})">
            <summary>
            Name of the parameter to resolve
            </summary>
            <param name="namedFunc"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetCtorParamConfiguration#UsingValueProvider(System.Func{System.Type,Grace.DependencyInjection.IExportValueProvider})">
            <summary>
            Provides a value for a constructor parameter
            </summary>
            <param name="valueProviderFunc">value provider for parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ImportProperty``1">
            <summary>
            Import properties of type TProperty and by name
            </summary>
            <typeparam name="TProperty">property type</typeparam>
            <returns>
            configuration object
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ImportProperty(System.Type)">
            <summary>
            Import all properties that match the type
            </summary>
            <param name="propertyType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetImportPropertyConfiguration#Named(System.String)">
            <summary>
            Property Name to import
            </summary>
            <param name="propertyName">property name</param>
            <returns>
            configuration object
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetImportPropertyConfiguration#IsRequired(System.Boolean)">
            <summary>
            Is it required
            </summary>
            <param name="value">is required</param>
            <returns>
            configuration object
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetImportPropertyConfiguration#Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Apply delegate to choose export
            </summary>
            <param name="consider">consider filter</param>
            <returns>
            configuration object
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetImportPropertyConfiguration#UsingValue(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Using Value provider
            </summary>
            <param name="activationDelegate"></param>
            <returns>
            configuration object
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Grace#DependencyInjection#IExportTypeSetImportPropertyConfiguration#UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Use value provider
            </summary>
            <param name="valueProvider">value provider</param>
            <returns>
            configuration object
            </returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.#ctor(Grace.DependencyInjection.IInjectionScope,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionScope"></param>
            <param name="scanTypes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterface(System.Type)">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <param name="interfaceType">interface type</param>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterface``1">
            <summary>
            Export all objects that implements the specified interface
            </summary>
            <returns>returns self</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByInterfaces(System.Func{System.Type,System.Boolean})">
            <summary>
            Export all classes by interface or that match a set of interfaces
            </summary>
            <param name="filterMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.BasedOn(System.Type)">
            <summary>
            Export all types based on speficied type
            </summary>
            <param name="baseType">base type to export</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.BasedOn``1">
            <summary>
            Export all types based on speficied type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByType(System.Func{System.Type,System.Type})">
            <summary>
            Export the selected classes by type
            </summary>
            <param name="typeDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            Export by a set of types for example ByTypes(t =&gt; t.GetTypeInfo().ImplementedInterfaces.Where(TypesThat.EndWith("Service")))
            </summary>
            <param name="typeDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByKeyedTypes(System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Tuple{System.Type,System.Object}}})">
            <summary>
            Export a type by a set of keyed types
            </summary>
            <param name="keyedDelegate">keyed types</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ByName(System.Func{System.Type,System.String})">
            <summary>
            Export by a particular name 
            </summary>
            <param name="nameDelegate">delegate used to create export name, default is type => type.Name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ILifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithPriority(System.Int32)">
            <summary>
            Export with the spcified priority
            </summary>
            <param name="priority">priority to export at</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithPriority(System.Func{System.Type,System.Int32})">
            <summary>
            Set priority based on a func
            </summary>
            <param name="priorityFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithPriorityAttribute``1">
            <summary>
            Priority will be set using a priority attribute
            </summary>
            <typeparam name="T"></typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export in the specified Environment
            </summary>
            <param name="environment">environment to export in</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExternallyOwned">
            <summary>
            Mark all exports as externally owned
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndWeakSingleton">
            <summary>
            Exports are to be marked as shared, similar to a singleton only using a weak reference.
            It can not be of type IDisposable
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndCondition(System.Func{System.Type,Grace.DependencyInjection.Conditions.IExportCondition})">
            <summary>
            And condition func
            </summary>
            <param name="conditionFunc">condition picker</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndSingleton">
            <summary>
            Export services as Singletons
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithKey(System.Func{System.Type,System.Object})">
            <summary>
            Provide a func that will be used to create a key that will be used to register
            </summary>
            <param name="withKeyFunc">key func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life cycle 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.ExportAttributedTypes">
            <summary>
            Export all attributed types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set a particular life style
            </summary>
            <param name="container">lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.UsingLifestyle(System.Func{System.Type,Grace.DependencyInjection.Lifestyle.ILifestyle})">
            <summary>
            Set a particular life style using a func
            </summary>
            <param name="lifestyleFunc">pick a lifestyle</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.EnrichWithExpression(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider}})">
            <summary>
            Enrich with linq expressions
            </summary>
            <param name="providers">providers</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Exclude(System.Func{System.Type,System.Boolean})">
            <summary>
            Exclude a type from being used
            </summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Select(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to filter out types based on the provided where clause
            </summary>
            <param name="whereClause"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.WithInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Adds a new inspector to the export configuration
            </summary>
            <param name="inspector"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Enrich all with a particular delegate
            </summary>
            <param name="enrichWithDelegate">enrichment delegate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.EnrichWith(System.Func{System.Type,System.Collections.Generic.IEnumerable{Grace.DependencyInjection.EnrichWithDelegate}})">
            <summary>
            Enrich with linq statements
            </summary>
            <param name="enrichWithDelegates">linq statement picker</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Enrich all with linq expressions
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportTypeSetConfiguration.Lifestyle">
            <summary>
            Assign a lifestyle to all exports
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ConfigurableExportStrategy">
            <summary>
            This is the base export class, it provides method to configure itself
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IConfigurableExportStrategy">
            <summary>
            This interface is implemented by classes that can be configured for exporting
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.Lock">
            <summary>
            Lock the export from changing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName">new export name</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType">new type to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddKeyedExportType(System.Type,System.Object)">
            <summary>
            Add a keyed export type for the strategy
            </summary>
            <param name="exportType">export type</param>
            <param name="key">export key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment">environment this export should be exported in</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority">priority for the export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetExternallyOwned">
            <summary>
            Set the export to be externally owned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.SetLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container">new Lifestyle container for the export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition">export condition for strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to export
            </summary>
            <param name="name">metadata name</param>
            <param name="value">metadata value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor takes the type to export
            </summary>
            <param name="exportType">export type</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose">
            <summary>
            Dispose this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Lock">
            <summary>
            Locks the export for any more changes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetKey(System.Object)">
            <summary>
            Set the key value for the strategy
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportName(System.String)">
            <summary>
            Add an export name for strategy
            </summary>
            <param name="exportName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddExportType(System.Type)">
            <summary>
            Add an export type for the strategy
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddKeyedExportType(System.Type,System.Object)">
            <summary>
            Add Keyed export type
            </summary>
            <param name="exportType"></param>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Set the export environment for the strategy
            </summary>
            <param name="environment"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetPriority(System.Int32)">
            <summary>
            Set the priority for the strategy
            </summary>
            <param name="priority"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetExternallyOwned">
            <summary>
            Set this export to be externally owned (IDisposable will not be tracked)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SetLifestyleContainer(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Set the life cycle container for the strategy
            </summary>
            <param name="container"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Add a condition to the export
            </summary>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope">injection scope that is activating this strategy (not always owning)</param>
            <param name="context">injection context</param>
            <param name="consider">export filter</param>
            <param name="locateKey">locate key</param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddMetadata(System.String,System.Object)">
            <summary>
            Add metadata to the export
            </summary>
            <param name="name">metadata name</param>
            <param name="value">metadata value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Dispose(System.Boolean)">
            <summary>
            Dispose of this object
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AddSecondaryExport(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a secondary export strategy to this strategy
            </summary>
            <param name="strategy">export strategy</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationType">
            <summary>
            Activation Type for this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Metadata">
            <summary>
            Metadata for export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ConfigurableExportStrategy.Log">
            <summary>
            Logger for strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncLocateKeyProvider">
            <summary>
            Locate key Provider that takes a func
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncLocateKeyProvider.#ctor(System.Func{System.Type,System.Object})">
            <summary>
            Default constructor
            </summary>
            <param name="locateKeyFunc">locate func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncLocateKeyProvider.#ctor(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type,System.Object})">
            <summary>
            Constructor that takes a full locate key func
            </summary>
            <param name="locateKeyFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncLocateKeyProvider.ProvideValue(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type)">
            <summary>
            Provide locate key
            </summary>
            <param name="injectionScope">current injection scope</param>
            <param name="context">current locate context</param>
            <param name="activationType">type being activated</param>
            <returns>locate key</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IInjectionScopeExtensions.RootScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Returns the root scope of the injection scope
            </summary>
            <param name="scope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1">
            <summary>
            Configures an exported instance lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportInstanceConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="strategyConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.Singleton">
            <summary>
            Applies a singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.WeakSingleton">
            <summary>
            Applies a weak singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerInjection">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerRequest">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerScope">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerAncestor``1(System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="metdata"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerAncestor(System.Type,System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="ancestorType">ancestor type</param>
            <param name="metdata">metadata object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceLifestyleConfiguration`1.SingletonPerNamedScope(System.String)">
            <summary>
            Exports will create a singleton per named scope
            </summary>
            <param name="scopeName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration">
            <summary>
            Configures a set of exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.#ctor(Grace.DependencyInjection.IExportTypeSetConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="typeSetConfiguration">export configuration</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.Singleton">
            <summary>
            Applies a singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.WeakSingleton">
            <summary>
            Applies a weak singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerInjection">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerRequest">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerScope">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerAncestor``1(System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="metdata"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerAncestor(System.Type,System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="ancestorType">ancestor type</param>
            <param name="metdata">metadata object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleBulkConfiguration.SingletonPerNamedScope(System.String)">
            <summary>
            Exports a type that will be shared per named scope
            </summary>
            <param name="namedScope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LifestyleConfiguration">
            <summary>
            Lifestyle configuration object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Default configuration object
            </summary>
            <param name="strategyConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.Singleton">
            <summary>
            Applies a singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.WeakSingleton">
            <summary>
            Applies a weak singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerInjection">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerRequest">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerScope">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerAncestor``1(System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="metdata"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerAncestor(System.Type,System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="ancestorType">ancestor type</param>
            <param name="metdata">metadata object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration.SingletonPerNamedScope(System.String)">
            <summary>
            Marks an export as singleton per named scope
            </summary>
            <param name="scopeName">name of scope to share export in</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LifestyleConfiguration`1">
            <summary>
            Lifestyle configuration object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default configuration object
            </summary>
            <param name="strategyConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.Singleton">
            <summary>
            Applies a singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.WeakSingleton">
            <summary>
            Applies a weak singleton lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerInjection">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerRequest">
            <summary>
            Applies a singleton per injection context lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerScope">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerAncestor``1(System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="metdata"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerAncestor(System.Type,System.Object)">
            <summary>
            Applies a singleton per scope lifestyle to the export
            </summary>
            <param name="ancestorType">ancestor type</param>
            <param name="metdata">metadata object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LifestyleConfiguration`1.SingletonPerNamedScope(System.String)">
            <summary>
            Exports will create a singleton per named scope
            </summary>
            <param name="scopeName"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PrioritizeTypesThatInspector">
            <summary>
            Prioritize types that match
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategyInspector">
            <summary>
            Classes the implement this interface can be used 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyInspector.Inspect(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Inspect a strategy as it's being added to the container.
            It will be called before the strategy Initialize method is called
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PrioritizeTypesThatInspector.#ctor(System.Func{System.Type,System.Boolean},System.Int32)">
            <summary>
            Default constructor
            </summary>
            <param name="typesThatFunc"></param>
            <param name="priority"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PrioritizeTypesThatInspector.Inspect(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Inspect strategies
            </summary>
            <param name="exportStrategy">strategy</param>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ILifestyle">
            <summary>
            ILifestyle objects are used to manage the Lifestyle of a particular export
            Singleton, Shared, Cached, and PerRequest are examples of Lifestyle containers
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ILifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.ILifestyle.Transient">
            <summary>
            If true then the container will allow the dependencies to be located in down facing scopes
            otherwise they will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.PropertyInjectionInspector">
            <summary>
            Strategy Inspector that marks certain properties for injection
            Must be used before the strategy is initialized (i.e. can be added after the export is configured)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.PropertyInjectionInspector.#ctor(System.Type,System.String,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Boolean,Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Default constructor
            </summary>
            <param name="propertyType">property type to import, can be generic</param>
            <param name="propertyName">name of the property to inject, can be null</param>
            <param name="propertyPicker"></param>
            <param name="afterConstructor"></param>
            <param name="valueProvider"></param>
        </member>
        <member name="T:Grace.DependencyInjection.PropertyInjectionInspector`1">
            <summary>
            Strategy Inspector that marks certain properties for injection
            Must be used before the strategy is initialized (i.e. can be added after the export is configured)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.PropertyInjectionInspector`1.#ctor(System.String,System.Func{System.Reflection.PropertyInfo,System.Boolean},System.Boolean,Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Default constructor
            </summary>
            <param name="propertyName"></param>
            <param name="propertyPicker"></param>
            <param name="afterConstructor"></param>
            <param name="valueProvider"></param>
        </member>
        <member name="T:Grace.DependencyInjection.TypeExtensions">
            <summary>
            Extension class for Type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypeExtensions.Matches(System.Type,System.Func{System.Type,System.Boolean})">
            <summary>
            Syntax glue to allow you to call type.Match(TypesThat.HaveAttribute(typeof(Attribute)))
            </summary>
            <param name="type">type</param>
            <param name="typeFilter">type filter (TypesThat will work here)</param>
            <returns>bool value</returns>
        </member>
        <member name="T:Grace.Diagnostics.IDependencyInjectionContainerExtensions">
            <summary>
            Dependency Injection Container extensions
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.IDependencyInjectionContainerExtensions.Diagnose(Grace.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Returns diagnostic information about the container by resolving a DependencyInjectionContainerDiagnostic object
            </summary>
            <param name="container">container</param>
            <returns>diagnostic information</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IEnumerableExtensions">
            <summary>
            Extensions for IEnumerable for dependency injection
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IEnumerableExtensions.ExportTo(System.Collections.Generic.IEnumerable{System.Type},Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Extension to export a list of types to a registration block
            </summary>
            <param name="types">list of types</param>
            <param name="registrationBlock">registration block</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocator">
            <summary>
            This interface can be used to locate an export. It's used by IInjectionScope and IDependencyInjectionContainer
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddStrategyInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate">delegate used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope provider for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule">configuration module used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">registration delegate used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule">configuration module used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns>new injection context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <param name="withKey"></param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer">used for sorting the imports when returning the list</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="exportFilter">export filter</param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategyCollection(System.Type,System.Boolean)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportType"></param>
            <param name="createIfDoesntExist"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.GetStrategyCollection(System.String,System.Boolean)">
            <summary>
            Get the export collection by name
            </summary>
            <param name="exportName">export name</param>
            <param name="createIfDoesntExist"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.Inject(System.Object,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Inject dependencies into a constructed object
            </summary>
            <param name="injectedObject">object to be injected</param>
            <param name="injectionContext">injection context</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocator.AddMissingExportStrategyProvider(Grace.DependencyInjection.IMissingExportStrategyProvider)">
            <summary>
            Missing export strategy providers can provide a set of exports that can be used to resolve a satisfy an import
            </summary>
            <param name="exportStrategyProvider">export strategy provider</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportLocator.Inspectors">
            <summary>
            List of Injection Inspectors for the scope
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportLocatorExtensions">
            <summary>
            Extension methods for IExportLocator
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.ConfigureWith``1(Grace.DependencyInjection.IExportLocator)">
            <summary>
            Configure container with IConfigurationModule
            </summary>
            <typeparam name="T"></typeparam>
            <param name="locator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.WhatDoIHave(Grace.DependencyInjection.IExportLocator,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            This method returns a summary of the exports contained in an ExportLocator
            </summary>
            <param name="locator">export locator to analyze</param>
            <param name="includeParent">include parent scope, false by default</param>
            <param name="consider">export filter to apply</param>
            <param name="injectionContext">injection context to use when filtering</param>
            <returns>diagnostic string</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``2(Grace.DependencyInjection.IExportLocator,``1,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type with a key
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="locator">locator to use</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context to use</param>
            <param name="consider">filter method to use</param>
            <returns>export T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.String,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by name and key
            </summary>
            <typeparam name="TKey">key type</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportName">name of export to locate</param>
            <param name="key">key to use during location</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter method</param>
            <returns>export object, null if no object found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateByKey``1(Grace.DependencyInjection.IExportLocator,System.Type,``0,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Locate an export by type and key
            </summary>
            <typeparam name="TKey">key type to locate</typeparam>
            <param name="locator">locator to use</param>
            <param name="exportType">type to locate</param>
            <param name="key">key to use while locating</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <returns>export object, null if no export found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.CompareKeyFunction(System.Object,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Function to compare a key to an export strategy
            </summary>
            <param name="key"></param>
            <param name="context"></param>
            <param name="strategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateAllWithMetadata``1(Grace.DependencyInjection.IExportLocator,System.String,System.Object,System.Boolean)">
            <summary>
            Locate all objects that are tagged with a particular piece of metadata
            </summary>
            <param name="exportLocator">export locator</param>
            <param name="metadataName">metadata name to locate</param>
            <param name="metadataValue">metadata value to test against, if null then any value metadata value will match</param>
            <param name="includeParent">locate in parent scope</param>
            <returns>returns list of objects</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateWithParameters``1(Grace.DependencyInjection.IExportLocator,System.Object[])">
            <summary>
            Locate with a set of value set into the context
            </summary>
            <typeparam name="T">Type to locate</typeparam>
            <param name="exportLocator">locator</param>
            <param name="parameters">parameters</param>
            <returns>located T</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.LocateWithNamedParameters``1(Grace.DependencyInjection.IExportLocator,System.Object)">
            <summary>
            Locate a T with named parameters
            </summary>
            <typeparam name="T">Type to locate</typeparam>
            <param name="exportLocator">export locator</param>
            <param name="namedParameter">named parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.CreateDisposableContext(Grace.DependencyInjection.IExportLocator)">
            <summary>
            Creates a new Disposable injection context to resolve from
            </summary>
            <param name="exportLocator">export locator to associate disposable context with</param>
            <returns>new context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportLocatorExtensions.BeginLifetimeScope(Grace.DependencyInjection.IExportLocator,System.String)">
            <summary>
            Creates a new light weight lifetime scope. You can not add new exports to this scope only resolve from it.
            If you need to create a new context that you can add exports to 
            </summary>
            <param name="exportLocator">export locate</param>
            <param name="scopeName">scope name for begin lifetime scope</param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportMetadata">
            <summary>
            Provides a threadsafe metadata container for exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportMetadata.MetadataMatches(System.String,System.Object)">
            <summary>
            Tests to see if metadata values match
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportMetadata.AddOrUpdate(System.String,System.Object)">
            <summary>
            Add or update a metadata value
            </summary>
            <param name="metadataName">metadata value name</param>
            <param name="metadataValue">metadata value</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportMetadata.Key">
            <summary>
            Key that the export was registered with
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IExportMetadata.IsEmpty">
            <summary>
            Returns true if there is no metadata.
            Note: this method is recommended over if(Count > 0)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlockExtensions">
            <summary>
            Extension methods for registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.PrioritizePartiallyClosedGenerics(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Ups the priority of partially closed generics based on the number of closed parameters
            </summary>
            <param name="registrationBlock">registration block</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.Prioritize(Grace.DependencyInjection.IExportRegistrationBlock,System.Func{System.Type,System.Boolean},System.Int32)">
            <summary>
            Prioritize types that match the provided delegate
            </summary>
            <param name="registrationBlock">registration block</param>
            <param name="typesThat">delegate to filter types</param>
            <param name="priority">priority to assign, default is 1</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.RegisterModule``1(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Register a configuration module
            </summary>
            <typeparam name="T">module type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.RegisterModule``1(Grace.DependencyInjection.IExportRegistrationBlock,``0)">
            <summary>
            Register a configuration module
            </summary>
            <typeparam name="T">module type</typeparam>
            <param name="registrationBlock">registration block</param>
            <param name="module">configuration module</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.RegisterModules(Grace.DependencyInjection.IExportRegistrationBlock,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Scans the list of types looking for IConfigurationModule types to register
            </summary>
            <param name="registrationBlock">registration block</param>
            <param name="types">types to scan</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.RegisterModules``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Scans the list of types looking for IConfigurationModule types to register
            </summary>
            <typeparam name="T">base module type</typeparam>
            <param name="registrationBlock">registration block</param>
            <param name="types">types to scan</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.RegisterModules(Grace.DependencyInjection.IExportRegistrationBlock,System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Scans the list of types looking for IConfigurationModule types to register
            </summary>
            <param name="registrationBlock">registration block</param>
            <param name="baseType">base type</param>
            <param name="types">types to scan</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlockExtensions.ExportNamedValue``1(Grace.DependencyInjection.IExportRegistrationBlock,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This is a short cut to registering a value as a name using the member name for exporting
            ExportNamedValue(() => someValue) export the value of someValue under the name someValue
            ExportInstance(someValue).AsName("someValue") is the long hand form
            </summary>
            <typeparam name="T"></typeparam>
            <param name="registrationBlock"></param>
            <param name="valueExpression"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions">
            <summary>
            extension methods for export type set configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.Prioritize(Grace.DependencyInjection.IExportTypeSetConfiguration,System.Func{System.Type,System.Boolean},System.Int32)">
            <summary>
            Prioritize specfic types that
            </summary>
            <param name="configuration">configuration object</param>
            <param name="typesThat">types that match func</param>
            <param name="priority">priority</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.UsingLifestyleConventions(Grace.DependencyInjection.IExportTypeSetConfiguration)">
            <summary>
            Configures exports lifestyles based on class name. If a class ends in Singleton or Service will be registered as Singleton,
            classes ending in Scoped, ScopedSingleton, or ScopedService will be registered as Scoped Singleton. Everything else will be transient
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.WithInspector(Grace.DependencyInjection.IExportTypeSetConfiguration,System.Action{Grace.DependencyInjection.Impl.ICompiledExportStrategy})">
            <summary>
            Adds an inspector action that can be used to configure all exports
            </summary>
            <param name="configuration">configuration object</param>
            <param name="inspector">inspector action</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.WithInspectorFor``1(Grace.DependencyInjection.IExportTypeSetConfiguration,System.Action{Grace.DependencyInjection.Impl.ICompiledExportStrategy})">
            <summary>
            Adds an inspector action for strategies that export the specified type, can be class or interface
            </summary>
            <typeparam name="T">type to inspect</typeparam>
            <param name="configuration">configuration object</param>
            <param name="inspector">inspector</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.WithInspectorFor(Grace.DependencyInjection.IExportTypeSetConfiguration,System.Type,System.Action{Grace.DependencyInjection.Impl.ICompiledExportStrategy})">
            <summary>
            Adds an inspector action for strategies that export the specified type, can be class or interface
            </summary>
            <param name="configuration">configuration object</param>
            <param name="inspectType">type to inspect</param>
            <param name="inspector">inspector</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.PrioritizePartiallyClosedGenerics(Grace.DependencyInjection.IExportTypeSetConfiguration)">
            <summary>
            Ups the priority of partially closed generics based on the number of closed parameters
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportTypeSetConfigurationExtensions.ProcessCustomEnrichmentExpressionAttributes(Grace.DependencyInjection.IExportTypeSetConfiguration)">
            <summary>
            Process all ICustomEnrichmentExpressionAttribute attributes
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportPropertyConfiguration">
            <summary>
            This interface configures a property for export
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration">
            <summary>
            This inteface allows you to configure an export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod">name of method to activate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsKeyed``2(``1)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <typeparam name="T">export type</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AsKeyed(System.Type,System.Object)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <param name="exportType">type to export under</param>
            <param name="key">export key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            Note: Only public writeable properties will be imported
            </summary>
            <param name="required">are all the properties required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ByInterfaces">
            <summary>
            Export the type by it's interfaces
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Using this method you can add your own linq expressions to the creation process
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.EnrichWithCustomConstructorExpression(Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionProvider)">
            <summary>
            Using this method you can add your own constructor logic 
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExportProperty(System.String)">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName">name of method to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.InNewContext">
            <summary>
            Export in a new context
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="lifestyle">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType">type of parameter</param>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType"></param>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithCtorParamCollection``2">
            <summary>
            Adds a constructor param of type TParam to the constructor
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration.WithName(System.String)">
            <summary>
            Export with a particular name
            </summary>
            <param name="exportName">export name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration.WithType(System.Type)">
            <summary>
            export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration.WithCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Export condition for the property
            </summary>
            <param name="exportCondition">export condition</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportPropertyConfiguration`2">
            <summary>
            This interface configures a property for export
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TProp"></typeparam>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1">
            <summary>
            This interface allows you to configure an export strategy for type T
            </summary>
            <typeparam name="T">type to export</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsKeyed``2(``1)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <typeparam name="TExportType">export type</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <param name="exportType">type to export under</param>
            <param name="key">export key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            USing this method you can add custom Linq Expressions to the expression tree 
            </summary>
            <param name="provider">provider class</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.EnrichWithCustomConstructorExpression(Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionProvider)">
            <summary>
            Using this method you can provide custom construction
            </summary>
            <param name="provider">custom constructor provider</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportCollectionProperty``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Import a property as a collection allowing for you to specify the sort order for the import
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.InNewContext">
            <summary>
            Create a new injection context for this export and it's children
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Attach a key to the export
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportStrategyConfiguration`1.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration`2.WithName(System.String)">
            <summary>
            Export with a particular name
            </summary>
            <param name="exportName">export name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration`2.WithType(System.Type)">
            <summary>
            Export with a particular type
            </summary>
            <param name="exportType">export type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportPropertyConfiguration`2.WithCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Export with a particular condition 
            </summary>
            <param name="exportCondition">export condition</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions">
            <summary>
            Extension methods for IFluentExportStrategyConfiguration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerInjectionContext(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Registers the export as singleton per injection context
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerInjectionContext``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0})">
            <summary>
            Registers the export as singleton per injection context
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerAncestor``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Object)">
            <summary>
            Registers the export as singleton per injection ancestor
            </summary>
            <typeparam name="TAncestor">ancestor type</typeparam>
            <param name="configuration">configuration object</param>
            <param name="metadataObject">metadata to match</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerAncestor``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Registers the export as singleton per injection ancestor
            </summary>
            <typeparam name="TAncestor">ancestor type</typeparam>
            <param name="configuration">configuration object</param>
            <param name="metadata">metadata to match</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerAncestor``2(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Registers the export as singleton per injection ancestor
            </summary>
            <typeparam name="T">ancestor type</typeparam>
            <typeparam name="TAncestor">ancestor type</typeparam>
            <param name="configuration">configuration object</param>
            <param name="metadata">metadata to match</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerRequest(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Register the export as singleton per request
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.AndSingletonPerRequest``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0})">
            <summary>
            Register the export as singleton per request
            </summary>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.WhenAncestor``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Export strategy when being inserted into object graph that has an ancestor of type TAncestor
            </summary>
            <typeparam name="TAncestor">ancestor type</typeparam>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.WhenAncestor``2(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0})">
            <summary>
            Export strategy when being inserted into object graph that has an ancestor of type TAncestor
            </summary>
            <typeparam name="TAncestor">ancestor type</typeparam>
            <typeparam name="T">type being exported</typeparam>
            <param name="configuration">configuration object</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.WithNamedCtorValue``1(Grace.DependencyInjection.IFluentExportStrategyConfiguration,System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            This is intended to be a short cut for setting named property values
            The expression will be inspected and the value will used by the property name
            WithNameCtorValue(() => someLocalVariable) will export the value under the name someLocalVariable
            WithCtorParam(() => someLocalVariable).Named("someLocalVariable") is the long hand form
            </summary>
            <typeparam name="TValue">value type being used</typeparam>
            <param name="strategy">export strategy</param>
            <param name="valueExpression">value expression, the name of the parameter will be used as the parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportStrategyConfigurationExtensions.WithNamedCtorValue``2(Grace.DependencyInjection.IFluentExportStrategyConfiguration{``0},System.Linq.Expressions.Expression{System.Func{``1}})">
            <summary>
            This is intended to be a short cut for setting named property values
            The expression will be inspected and the value will used by the property name
            WithNameCtorValue(() => someLocalVariable) will export the value under the name someLocalVariable
            </summary>
            <typeparam name="T">Type being exported</typeparam>
            <typeparam name="TValue">value type being used</typeparam>
            <param name="strategy">export strategy</param>
            <param name="valueExpression">value expression, the name of the parameter will be used as the parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportPropertyCollectionConfiguration`2">
            <summary>
            Configuration interface for exporting a collection
            </summary>
            <typeparam name="T">exported type</typeparam>
            <typeparam name="TItem">property collection type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyCollectionConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            filter to be used when filling collection
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyCollectionConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a specific key
            </summary>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort the collection using an IComparer
            </summary>
            <param name="comparer">comparer</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the collection by property
            </summary>
            <param name="propertyFunc">function to retrieve property</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportMethodConfiguration">
            <summary>
            Configuration interface to configure an importing a method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportMethodConfiguration.AfterConstruction">
            <summary>
            Import the methods parameters after consrtuction instead of the default before
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportMethodConfiguration.WithParam``1(System.Func{``0})">
            <summary>
            specify how to import a particular parameter
            </summary>
            <typeparam name="TParam">parameter type</typeparam>
            <param name="paramValueFunc">value func</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentMethodParameterConfiguration`1">
            <summary>
            method parameter configuration object
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`1.ImportParameterAfterConstruction">
            <summary>
            Import the parameter after construction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required
            </summary>
            <param name="isRequired">is required, true by default</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`1.ImportName(System.String)">
            <summary>
            Name to use when importing
            </summary>
            <param name="importName">import name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`1.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Specify a value provider for this parameter
            </summary>
            <param name="valueProvider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportMethodConfiguration`1">
            <summary>
            Configuration object for importing a method
            </summary>
            <typeparam name="T">type being exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportMethodConfiguration`1.WithMethodParam``1(System.Func{``0})">
            <summary>
            specify how to import a particular method parameter
            </summary>
            <typeparam name="TParam">parameter type</typeparam>
            <param name="paramValueFunc">value provider func</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2">
            <summary>
            method parameter configuration interface
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <typeparam name="TParam">parameter type being exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.ImportName(System.String)">
            <summary>
            Name to use when importing parameter
            </summary>
            <param name="importName">import name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.ImportParameterAfterConstruction">
            <summary>
            Import parameter after construction
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a specific key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.Named(System.String)">
            <summary>
            parameter name
            </summary>
            <param name="parameterName">parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentMethodParameterConfiguration`2.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Value provider for method parameter
            </summary>
            <param name="valueProvider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportPropertyConfiguration">
            <summary>
            Configuration interface for importing a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.AfterConstruction">
            <summary>
            Import the property value after construction. Usually this is done before construction
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            filter to use when importing
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.UsingValue(System.Func{System.Object})">
            <summary>
            Specify a value to use when importing the property
            </summary>
            <param name="valueFunc">property func</param>
            <returns>configuration value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Value provider for property
            </summary>
            <param name="provider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2">
            <summary>
            configuration object for importing a property
            </summary>
            <typeparam name="T">exporting type</typeparam>
            <typeparam name="TProp">type of property to export</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.AfterConstruction">
            <summary>
            Import the property value after construction. Usually this is done before construction
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            use a filter delegate when importing property
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.UsingValue(System.Func{`1})">
            <summary>
            Provide value for import property
            </summary>
            <param name="valueFunc">value func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.UsingValue(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,`1})">
            <summary>
            Provide value for import property
            </summary>
            <param name="valueFunc">value func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentImportPropertyConfiguration`2.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            specify value provider for property import
            </summary>
            <param name="provider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration">
            <summary>
            Simple export strategy, used to export a type using only Constructor injection
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="lifestyle">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentSimpleExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1">
            <summary>
            Configuration object for an imoprt collection
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.Named(System.String)">
            <summary>
            Specify a name of the parameter being configured
            </summary>
            <param name="name">name of parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.SortBy(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`1.SortByProperty(System.Func{`0,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2">
            <summary>
            Configuration object for an imoprt collection
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.Named(System.String)">
            <summary>
            Specify a name of the parameter being configured
            </summary>
            <param name="name">name of parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a specific key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorConfiguration">
            <summary>
            Interface to configure a constructor parameter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving a parameter constructor
            It will be called each time the parameter is resolved
            </summary>
            <param name="filter">filter delegate to be used when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.ImportName(System.String)">
            <summary>
            Name to use when resolving parameter
            </summary>
            <param name="importName"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required when resolving the type
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">ocate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.LocateWithKeyProvider(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type,System.Object})">
            <summary>
            Locate with a particular key using a provided func
            </summary>
            <param name="locateKeyFunc">locate key func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.LocateWithKeyProvider(Grace.DependencyInjection.ILocateKeyValueProvider)">
            <summary>
            Locate with a particular key provider
            </summary>
            <param name="keyProvider">key provder</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.Named(System.String)">
            <summary>
            Name of the parameter to resolve
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Provides a value for a constructor parameter
            </summary>
            <param name="valueProvider">value provider for parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentWithCtorConfiguration`1">
            <summary>
            Interface to configure a constructor parameter
            </summary>
            <typeparam name="T">type being exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Applies a filter to be used when resolving the parameter
            The filter will be used each time this parameter is resolved
            </summary>
            <param name="filter">filter delegate to use when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.ImportName(System.String)">
            <summary>
            Name to use when resolving parameter
            </summary>
            <param name="importName">name to use when resolving parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required to resolve T
            </summary>
            <param name="isRequired">is the parameter required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.LocateWithKeyProvider(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Type,System.Object})">
            <summary>
            Locate with a particular key using a provided func
            </summary>
            <param name="locateKeyFunc">locate key func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.LocateWithKeyProvider(Grace.DependencyInjection.ILocateKeyValueProvider)">
            <summary>
            Locate with a particular key provider
            </summary>
            <param name="keyProvider">key provder</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.Named(System.String)">
            <summary>
            Name of the parameter being configured
            </summary>
            <param name="name">Name of parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentWithCtorConfiguration`1.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Value provider to use when resolving constructor parameter
            </summary>
            <param name="valueProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Diagnostics.IInjectionScopeExtensions">
            <summary>
            C# extension methods for IInjectionScope
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.IInjectionScopeExtensions.Diagnose(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Returns information about the injection scope
            </summary>
            <param name="injectionScope">injection scope</param>
            <returns>diagnostic information</returns>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionStrategy">
            <summary>
            Provides a mechanism to inject an object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionStrategy.Initialize">
            <summary>
            Initialize the injection strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IInjectionStrategy.Inject(Grace.DependencyInjection.IInjectionContext,System.Object)">
            <summary>
            Inject an object
            </summary>
            <param name="injectionContext"></param>
            <param name="injectTarget"></param>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionStrategy.TargeType">
            <summary>
            Type that this strategy targets
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.AttributedInjectionStrategy">
            <summary>
            Injection strategy that uses attributes to define it's construction
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseInjectionStrategy.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseInjectionStrategy.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Configure the export to import a property
            </summary>
            <param name="propertyInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseInjectionStrategy.EnrichmentExpressionProvider(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Add enrichment provider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BaseInjectionStrategy.InNewContext">
            <summary>
            Mark export to be constructed in a new context
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseInjectionStrategy.TargeType">
            <summary>
            Target type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.BaseInjectionStrategy.Attributes">
            <summary>
            Attributes
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributedInjectionStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributedInjectionStrategy.Initialize">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.AttributeExportStrategy">
            <summary>
            Exports a type using attributes to define how it should be exported
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy">
            <summary>
            This class exports a type using linq expressions
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExportStrategy">
            <summary>
            Represents an export strategy that can be configured to build a CompiledExportDelegate
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICompiledExportStrategy">
            <summary>
            This interface represents an export strategy that can be configured for importing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Configure the export to import a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ExportProperty(Grace.DependencyInjection.Impl.ExportPropertyInfo)">
            <summary>
            mark a property for exporting
            </summary>
            <param name="exportProperty"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Adds custom provider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICompiledExportStrategy.InNewContext">
            <summary>
            Export class in new injection context
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.#ctor(System.Type)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Configure the export to import a method
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Configure the export to import a property
            </summary>
            <param name="propertyInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Configure a method for activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Specify a particular constructor
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds a cleanup delegate to export strategy
            </summary>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Adds custom provider
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.InNewContext">
            <summary>
            Export in new context
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExportStrategy.GetCompiledInfo">
            <summary>
            Gets the CompiledExportDelegateInfo definition for this export
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExportStrategy.CreatingStrategy">
            <summary>
            When the strategy has been created by a generic strategy this will be set to the strategy that created it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledInstanceExportStrategy.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            DEfault constructor
            </summary>
            <param name="exportType"></param>
            <param name="attributes"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.AttributeExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedAttributeExportStrategy.Equals(System.Object)">
            <summary>
            OVerride equals to compare if to closed generics are equal
            </summary>
            <param name="obj">object to compare</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedAttributeExportStrategy.GetHashCode">
            <summary>
            Gets hashcode of activation name
            </summary>
            <returns>hash code value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy">
            <summary>
            Closed generic strategy is used to create closed strategies by the generic strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.Equals(System.Object)">
            <summary>
            OVerride equals to compare if to closed generics are equal
            </summary>
            <param name="obj">object to compare</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ClosedGenericExportStrategy.GetHashCode">
            <summary>
            Gets hashcode of activation name
            </summary>
            <returns>hash code value</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext">
            <summary>
            Default implementation for ICustomEnrichmentLinqExpressionContext
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.#ctor(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.List{System.Linq.Expressions.ParameterExpression})">
            <summary>
            default constructor
            </summary>
            <param name="activationType">type being activated</param>
            <param name="exportStrategyScopeParameter">injection scope parameter</param>
            <param name="injectionContextParameter">injection context parameter</param>
            <param name="instanceVariable">instance being constructed</param>
            <param name="localVariables">local variables</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.AddLocalVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Parameters added usingt his method will be added to the main body of the delegate
            </summary>
            <param name="newLocalVariable">new local variable</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.ActivationType">
            <summary>
            Type being constructed
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.ExportStrategyScopeParameter">
            <summary>
            The IInjectionScope this strategy is being call with
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.InjectionContextParameter">
            <summary>
            Injection context parameter (IInjectionContext)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CustomEnrichmentLinqExpressionContext.InstanceVariable">
            <summary>
            Instance being created (object)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate">
            <summary>
            This class creates a compiled delegate that can be used for export
            It uses a function to create a new instance
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate">
            <summary>
            This class is used to create a delegate that creates an export and statisfies all it's imports
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.disposalExpressions">
            <summary>
            List of expressions for handling IDisposable
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.exportStrategyScopeParameter">
            <summary>
            The IInjectionScope parameter for the strategy
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.injectionContextParameter">
            <summary>
            The IInjectionContext parameter
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceExpressions">
            <summary>
            List of expressions used to construct the instance
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.instanceVariable">
            <summary>
            Variable that represents the instance being constructed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="exportDelegateInfo">information for compiling the delegate</param>
            <param name="owningStrategy"></param>
            <param name="owningScope">the owning scope</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CompileDelegate">
            <summary>
            Compiles the export delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.Initialize">
            <summary>
            Initialize the delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.GenerateDelegate">
            <summary>
            This method generates the compiled delegate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpParameterExpressions">
            <summary>
            Sets up the parameters for the delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.SetUpInstanceVariableExpression">
            <summary>
            Sets up a local variable that hold the instance that will be injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateNewContextExpression">
            <summary>
            Exports can be created in a new context if configured to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateCustomInitializeExpressions">
            <summary>
            This method creates expressions that call Initialization methods (i.e. methods that take IInjectionContext and are called after
            construction and before properties are injected)
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreatePropertyImportExpressions">
            <summary>
            Creates all the import expressions for properties that are being injected
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateMethodImportExpressions">
            <summary>
            Creates all method import expressions for the export
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateActivationMethodExpressions">
            <summary>
            Create all the expressions for activatition methods
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateDisposableMethodExpression">
            <summary>
            Create expressions for disposable objects
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateCustomEnrichmentExpressions">
            <summary>
            Create all custom enrichment expressions
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateEnrichmentExpression">
            <summary>
            
            </summary>
            <returns>true if there was an enrichment expression created</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.ExecuteEnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object)">
            <summary>
            This method is used to execute an EnrichWithDelegate
            </summary>
            <param name="enrichWithDelegate"></param>
            <param name="scope"></param>
            <param name="context"></param>
            <param name="injectObject"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateReturnExpression">
            <summary>
            Creates a return expression 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateImportExpression(System.Type,Grace.DependencyInjection.IInjectionTargetInfo,Grace.DependencyInjection.ExportStrategyDependencyType,System.String,System.String,System.Boolean,Grace.DependencyInjection.IExportValueProvider,Grace.DependencyInjection.ExportStrategyFilter,Grace.DependencyInjection.ILocateKeyValueProvider,System.Object,System.Collections.Generic.List{System.Linq.Expressions.Expression})">
            <summary>
            Creates a local variable an then tries to import the value
            </summary>
            <param name="importType"></param>
            <param name="targetInfo"></param>
            <param name="dependencyType"></param>
            <param name="exportName"></param>
            <param name="variableName"></param>
            <param name="isRequired"></param>
            <param name="valueProvider"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <param name="comparerObject"></param>
            <param name="expressionList"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFunc``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Creates a new Func(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="context"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncWithContext``1(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Creates a new Func(IInjectionContext,T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncType(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Creates a new Func(Type,object) for resolving type without having to access container
            </summary>
            <param name="context">injection context to use</param>
            <param name="exportStrategyFilter">export filter to use when locating</param>
            <param name="locateKey">locate key</param>
            <returns>new Func(Type,object)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateFuncTypeWithContext(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Create a new Func(Type, IInjectionContext, object) for resolving type without having to access container
            </summary>
            <param name="injectionScope"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateOwned``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Creates a new Owned(T)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.CreateLazy``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Create a new Lazy(T) 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="exportStrategyFilter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.ConvertNamedExportToPropertyType(System.Object,Grace.Utilities.TypeWrapper)">
            <summary>
            Converts a object value to a new type
            </summary>
            <param name="targetValue">value to convert</param>
            <param name="targetType">type to convert to</param>
            <returns>return value</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.BaseCompiledExportDelegate.Dependencies">
            <summary>
            Dependencies for this compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="activationDelegate"></param>
            <param name="exportStrategy"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.CreateInstantiationExpression">
            <summary>
            This method creates the expression that calls the constructor or function to create a new isntance that will be returned
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.FuncCompiledExportDelegate.InvokeActivationDelegate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Method used to invoke an activation delegate
            </summary>
            <param name="exportStrategyScope"></param>
            <param name="activationDelegate"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.InjectionTargetExtraDataKey">
            <summary>
            Extra Data Key for Injection Target
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="exportStrategy"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InjectionCompiledExportDelegate.LocateInjectionObject(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Returns the injection target
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate">
            <summary>
            This class compiles a delegate to be used for exporting. 
            It creates a new instance using the types constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.#ctor(Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportDelegateInfo"></param>
            <param name="exportStrategy"></param>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.InstanceCompiledExportDelegate.PickConstructor(System.Type)">
            <summary>
            Picks the specific constructor to use for exporting
            </summary>
            <param name="activationType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.SimpleCompiledExportDelegate.GenerateDelegate">
            <summary>
            This method generates the compiled delegate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy">
            <summary>
            Base class to be used to import generic delegates
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the object
            </summary>
            <param name="exportInjectionScope">injetion scope</param>
            <param name="context">context for the activation</param>
            <param name="consider">consider filter</param>
            <param name="locateKey"></param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Initialize">
            <summary>
            Base initialize
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Always meets condition
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.SecondaryStrategies">
            <summary>
            Secondary strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Enrich with delegate
            </summary>
            <param name="enrichWithDelegate">enrichment delegate</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.ActivationType">
            <summary>
            Activation Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.ActivationName">
            <summary>
            Activation name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.AllowingFiltering">
            <summary>
            Allow filtering of type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Attributes">
            <summary>
            Empty list of attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.OwningScope">
            <summary>
            Owning scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Key">
            <summary>
            Export strategy key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.ExportNames">
            <summary>
            List of export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Environment">
            <summary>
            Export as any
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Priority">
            <summary>
            Priority of zero
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Lifestyle">
            <summary>
            Has no lifestyle
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.HasConditions">
            <summary>
            Has no conditions
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.ExternallyOwned">
            <summary>
            Externally owned is false
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.Metadata">
            <summary>
            Metadata for export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericDelegateExportStrategy.DependsOn">
            <summary>
            Doesn't depend on anything
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7">
            <summary>
            Export Strategy for any delegate that can match Func&lt;Targ1,TArg2,TReturn&gt;
            </summary>
            <typeparam name="TDelegate">delegate type to construct</typeparam>
            <typeparam name="TReturn">return type of delegate</typeparam>
            <typeparam name="TArg1">arguement one type</typeparam>
            <typeparam name="TArg2">arguement two type</typeparam>
            <typeparam name="TArg3">arguement three type</typeparam>
            <typeparam name="TArg4">arguement four type</typeparam>
            <typeparam name="TArg5">arguement five type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.ActivationName">
            <summary>
            Activation Name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.ExportTypes">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.Helper">
            <summary>
            Helper class for binding the delegate to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.Helper.#ctor(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="argName1"></param>
            <param name="argName2"></param>
            <param name="argName3"></param>
            <param name="argName4"></param>
            <param name="argName5"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`7.Helper.Activate(`2,`3,`4,`5,`6)">
            <summary>
            Activate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <param name="arg5"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6">
            <summary>
            Export Strategy for any delegate that can match Func&lt;Targ1,TArg2,TReturn&gt;
            </summary>
            <typeparam name="TDelegate">delegate type to construct</typeparam>
            <typeparam name="TReturn">return type of delegate</typeparam>
            <typeparam name="TArg1">arguement one type</typeparam>
            <typeparam name="TArg2">arguement two type</typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.ActivationName">
            <summary>
            Activation Name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.ExportTypes">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.Helper">
            <summary>
            Helper class for binding the delegate to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.Helper.#ctor(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.String,System.String,System.String,System.String)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="argName1"></param>
            <param name="argName2"></param>
            <param name="argName3"></param>
            <param name="argName4"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`6.Helper.Activate(`2,`3,`4,`5)">
            <summary>
            Activate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2">
            <summary>
            Export strategy for any delegate that matches Func&lt;T&gt;
            </summary>
            <typeparam name="TDelegate">delegate type</typeparam>
            <typeparam name="TReturn">delegate return type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activates a new TDelegate by binding to a new helper
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.ActivationName">
            <summary>
            Activation name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.ExportTypes">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.Helper">
            <summary>
            Helper class that is used to bind the delegate type to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.Helper.#ctor(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            DEfault constructor
            </summary>
            <param name="context">injection context</param>
            <param name="consider">consider delegate</param>
            <param name="locateKey">locate key</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`2.Helper.Activate">
            <summary>
            This the method that is bound to the delegate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3">
            <summary>
            Export Strategy for delegates that match the signature Func&lt;TArg1,TReturn&gt;
            </summary>
            <typeparam name="TDelegate"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <typeparam name="TArg1"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3.Initialize">
            <summary>
            Initialize
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the object
            </summary>
            <param name="exportInjectionScope">injetion scope</param>
            <param name="context">context for the activation</param>
            <param name="consider">consider filter</param>
            <param name="locateKey"></param>
            <returns>
            activated object
            </returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3.ActivationType">
            <summary>
            Activation Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3.ActivationName">
            <summary>
            Activation name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`3.ExportTypes">
            <summary>
            List of export types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5">
            <summary>
            Export Strategy for any delegate that can match Func&lt;Targ1,TArg2,TReturn&gt;
            </summary>
            <typeparam name="TDelegate">delegate type to construct</typeparam>
            <typeparam name="TReturn">return type of delegate</typeparam>
            <typeparam name="TArg1">arguement one type</typeparam>
            <typeparam name="TArg2">arguement two type</typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.ActivationName">
            <summary>
            Activation Name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.ExportTypes">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.Helper">
            <summary>
            Helper class for binding the delegate to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.Helper.#ctor(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.String,System.String,System.String)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="argName1"></param>
            <param name="argName2"></param>
            <param name="argName3"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`5.Helper.Activate(`2,`3,`4)">
            <summary>
            Activate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4">
            <summary>
            Export Strategy for any delegate that can match Func&lt;Targ1,TArg2,TReturn&gt;
            </summary>
            <typeparam name="TDelegate">delegate type to construct</typeparam>
            <typeparam name="TReturn">return type of delegate</typeparam>
            <typeparam name="TArg1">arguement one type</typeparam>
            <typeparam name="TArg2">arguement two type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.ActivationName">
            <summary>
            Activation Name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.ExportTypes">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.Helper">
            <summary>
            Helper class for binding the delegate to
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.Helper.#ctor(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.String,System.String)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="argName1"></param>
            <param name="argName2"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericDelegateExportStrategy`4.Helper.Activate(`2,`3)">
            <summary>
            Activate method
            </summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportActivationValueProvider">
            <summary>
            Wraps an export activation delegate to use as a value provider
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportActivationValueProvider.#ctor(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="activationDelegate">activation delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportActivationValueProvider.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportMetadata">
            <summary>
            Export metadata 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.#ctor(System.Object,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Default Constructor
            </summary>
            <param name="key"></param>
            <param name="dictionary"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.MetadataMatches(System.String,System.Object)">
            <summary>
            Tests to see if metadata values match
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.AddOrUpdate(System.String,System.Object)">
            <summary>
            Adds or updates a metadata value. 
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.GetEnumerator">
            <summary>
            Gets an enumerator for the metadata
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for the metadata
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.ContainsKey(System.String)">
            <summary>
            Returns true if there is a metadata value by the specified name
            </summary>
            <param name="key">metadata key</param>
            <returns>true if key exists</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportMetadata.TryGetValue(System.String,System.Object@)">
            <summary>
            Attemps to fetch the metadata value by the specified key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.Key">
            <summary>
            Key the export was registered with
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.IsEmpty">
            <summary>
            Returns true if there is no metadata.
            Note: this method is recommended over if(Count > 0)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.Count">
            <summary>
            Gets a count of the metadata
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.Item(System.String)">
            <summary>
            Returns the metadata value by the specified key
            </summary>
            <param name="key">key</param>
            <returns>metadata value</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.Keys">
            <summary>
            Metadata keys for this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportMetadata.Values">
            <summary>
            Metadata values for this export
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration">
            <summary>
            Base export strategy configuration
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ByInterfaces">
            <summary>
            Export the type by it's interfaces
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.InNewContext">
            <summary>
            Export in a new context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
            <param name="methodName">name of method to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.EnrichWithCustomConstructorExpression(Grace.DependencyInjection.ICustomConstructorEnrichmentLinqExpressionProvider)">
            <summary>
            Using this method you can add your own constructor logic 
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ExportProperty(System.String)">
            <summary>
            Export a specific property under a particular name
            </summary>
            <param name="propertyName">name of property to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod">name of method to activate</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="container">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            Note: Only public writeable properties will be imported
            </summary>
            <param name="required">are all the properties required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Using this method you can add your own linq expressions to the creation process
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType">type of parameter</param>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType"></param>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.WithCtorParamCollection``2">
            <summary>
            Adds a constructor param of type TParam to the constructor
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1">
            <summary>
            Base export strategy configuration
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.InNewContext">
            <summary>
            Export in new injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithKey(System.Object)">
            <summary>
            Attach a key to the export
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( () => new MyTypeName("Specific", "Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( () => new MyTypeName("Specific", "Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportCollectionProperty``1(System.Linq.Expressions.Expression{System.Func{`0,System.Collections.Generic.IEnumerable{``0}}})">
            <summary>
            Import a property as a collection allowing for you to specify the sort order for the import
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a method to be called upon activation passing in an arguement that has be located using the IoC
            </summary>
            <param name="method">method to import</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Export a property to be imported by other exports
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.WithCtorCollectionParam``2">
            <summary>
            Import a collection allowing you to specify a filter and a sort order
            </summary>
            <typeparam name="TParam"></typeparam>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            USing this method you can add custom Linq Expressions to the expression tree 
            </summary>
            <param name="provider">provider class</param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentBaseExportConfiguration`1.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration">
            <summary>
            This class allows you to configure a type for exporting using fluent syntax
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExportProperty(System.String)">
            <summary>
            Export a property by name
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportMethod(System.String)">
            <summary>
            Mark a method for importing
            </summary>
            <param name="methodName">method name to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProcessCurrentImportMethodInfo">
            <summary>
            Process the current import method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportProperty(System.String)">
            <summary>
            Mark a property for import and specify if its required
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.LocateWithKey(System.Object)">
            <summary>
            Locate with a key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            filter to use when importing
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingValue(System.Func{System.Object})">
            <summary>
            Specify a value to use when importing the property
            </summary>
            <param name="valueFunc">property func</param>
            <returns>configuration value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Value provider for property
            </summary>
            <param name="provider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AfterConstruction">
            <summary>
            Import the property value after construction. Usually this is done before construction
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType">type of parameter</param>
            <param name="paramValue">Func(T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <param name="parameterType"></param>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProcessCurrentConstructorParamInfo">
            <summary>
            Processes the current constructor parameter that was being configured
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.#ctor(System.Type,Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType">type being exported</param>
            <param name="exportStrategy">configurable strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.InNewContext">
            <summary>
            Export in a new context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of calling Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Allows you to specify an import constructor
            </summary>
            <param name="constructorInfo">ConstrcutorInfo object to use during construction</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.ActivationMethod(System.String)">
            <summary>
            Method to call when activation is done
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.AutoWireProperties(System.Boolean)">
            <summary>
            Marks all properties on the object for injection
            </summary>
            <param name="required"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Enrich with a linq expression
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1">
            <summary>
            This class configures a particular type for export using fluent syntax
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Exports  a property on an object
            </summary>
            <typeparam name="TProp"></typeparam>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a method for importing
            </summary>
            <param name="method">method to import</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ProcessCurrentImportMethodInfo">
            <summary>
            Process the current method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportAttributedMembers">
            <summary>
            Imports all public properties and methods that are attributed
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Mark a property for Import (using dependency injection container)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{``0})">
            <summary>
            Add a value to be used for constructor parameters
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(TParam) for the parameter</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam(System.Type,System.Func{System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam``1(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,``0})">
            <summary>
            Add a specific value for a particuar parameter in the constructor
            </summary>
            <typeparam name="TParam">type of parameter</typeparam>
            <param name="paramValue">Func(IInjectionScope, IInjectionContext, T) value for the parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithCtorParam(System.Type,System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.Object})">
            <summary>
            Add a vlue to be used for constructor parameter
            </summary>
            <param name="parameterType">parameter type</param>
            <param name="paramValue">parameter value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.#ctor(Grace.DependencyInjection.Impl.ICompiledExportStrategy)">
            <summary>
            Default constructor
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.As(System.Type)">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ByInterfaces">
            <summary>
            Export the type by the interfaces it implements
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.InNewContext">
            <summary>
            Create a new injection context for this export and it's children
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithKey(System.Object)">
            <summary>
            Export under a specific key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ImportConstructor(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            This method allows you to specify which constructor to use ( x => new MyTypeName("Specific","Constructor") )
            </summary>
            <param name="constructorExpression">constructor expression ( x => new MyTypeName("Specific","Constructor") )</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.ActivationMethod(System.Linq.Expressions.Expression{System.Action{`0}})">
            <summary>
            Mark a particular Action() as the activation action
            </summary>
            <param name="activationMethod"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom life cycle container for the export
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.AutoWireProperties(System.Boolean)">
            <summary>
            Sets up all public writable properties on the type to be injected
            </summary>
            <param name="required">are the properties required</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.EnrichWithExpression(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            
            </summary>
            <param name="provider"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FluentExportStrategyConfiguration`1.Lifestyle">
            <summary>
            Applies a lifestyle to an export
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration">
            <summary>
            Configuration object for exporting a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration.#ctor(Grace.DependencyInjection.Impl.ExportPropertyInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="exportPropertyInfo">property info to export</param>
            <param name="strategy">export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration.WithName(System.String)">
            <summary>
            Export with a particular name
            </summary>
            <param name="exportName">export name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration.WithType(System.Type)">
            <summary>
            export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration.WithCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Export condition for the property
            </summary>
            <param name="exportCondition">export condition</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration`2">
            <summary>
            Conifugration object for exporting a property
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <typeparam name="TProp">property type being exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration`2.#ctor(Grace.DependencyInjection.Impl.ExportPropertyInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Deafult constructor
            </summary>
            <param name="exportPropertyInfo"></param>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration`2.WithName(System.String)">
            <summary>
            Export with a particular name
            </summary>
            <param name="exportName">export name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration`2.WithType(System.Type)">
            <summary>
            Export with a particular type
            </summary>
            <param name="exportType">export type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentExportPropertyConfiguration`2.WithCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Export with a particular condition 
            </summary>
            <param name="exportCondition">export condition</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentImportMethodConfiguration">
            <summary>
            Configuration object for importing a method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportMethodConfiguration.#ctor(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="methodInfo">method to import</param>
            <param name="strategy">strategy to configure</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`1">
            <summary>
            Parameter configuration object
            </summary>
            <typeparam name="TParam"></typeparam>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentImportMethodConfiguration`1">
            <summary>
            Object for configuring a method for importing
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportMethodConfiguration`1.#ctor(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="methodInfo">method to import</param>
            <param name="strategy">trategy to configure</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportMethodConfiguration`1.WithMethodParam``1(System.Func{``0})">
            <summary>
            Configure a particular parameter in a method
            </summary>
            <typeparam name="TParam"></typeparam>
            <param name="paramValueFunc"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2">
            <summary>
            Parameter configuration object
            </summary>
            <typeparam name="T">type being exported</typeparam>
            <typeparam name="TProp">parameter type being configured</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.#ctor(Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo,Grace.DependencyInjection.Impl.FluentImportMethodConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="methodInfo"></param>
            <param name="importMethodConfiguration"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.WithMethodParam``1(System.Func{``0})">
            <summary>
            Specify a particular parameter 
            </summary>
            <typeparam name="TParam">parameter type</typeparam>
            <param name="paramValueFunc">value providing func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.Named(System.String)">
            <summary>
            specify parameter name
            </summary>
            <param name="parameterName">parameter name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the parameter required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.ImportName(System.String)">
            <summary>
            Name to use when importing parameter
            </summary>
            <param name="importName">Import name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentMethodParameterConfiguration`2.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            Using a specified value provider
            </summary>
            <param name="valueProvider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2">
            <summary>
            Configuration object fo importing property
            </summary>
            <typeparam name="T">type being injected</typeparam>
            <typeparam name="TProp">property type import</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.#ctor(Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0},Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="strategy">strategy</param>
            <param name="importPropertyInfo">import info</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.IsRequired(System.Boolean)">
            <summary>
            Is the property required
            </summary>
            <param name="isRequired">is required</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            use a filter delegate when importing property
            </summary>
            <param name="consider">filter delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.UsingValue(System.Func{`1})">
            <summary>
            Provide value for import property
            </summary>
            <param name="valueFunc">value func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.UsingValue(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,`1})">
            <summary>
            Provide value for import property
            </summary>
            <param name="valueFunc">value func</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.UsingValueProvider(Grace.DependencyInjection.IExportValueProvider)">
            <summary>
            specify value provider for property import
            </summary>
            <param name="provider">value provider</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentImportPropertyConfiguration`2.AfterConstruction">
            <summary>
            Import the property value after construction. Usually this is done before construction
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1">
            <summary>
            Configuration object for constructor parameters
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.#ctor(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration)">
            <summary>
            Default constructor
            </summary>
            <param name="paramInfo"></param>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.SortByProperty(System.Func{`0,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.LocateWithKey(System.Object)">
            <summary>
            Locate with a particular key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.SortBy(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`1.Named(System.String)">
            <summary>
            Specify a name of the parameter being configured
            </summary>
            <param name="name">name of parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2">
            <summary>
            Configuration object for parameters that are collections
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.#ctor(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo,Grace.DependencyInjection.IFluentExportStrategyConfiguration{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="paramInfo">param info to configure</param>
            <param name="strategy">export strategy</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.Consider(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Provide a filter for which exports should be used
            </summary>
            <param name="consider">Filter to use to filter out export strategies</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.SortByProperty(System.Func{`1,System.IComparable})">
            <summary>
            Sort the import collection by a particular property on TItem
            </summary>
            <param name="propertyFunc">func to use to access property on TItem</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.LocateWithKey(System.Object)">
            <summary>
            Locate with a specific key
            </summary>
            <param name="locateKey">locate key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.SortBy(System.Collections.Generic.IComparer{`1})">
            <summary>
            Sort an import collection before it's being injected
            </summary>
            <param name="comparer">comparer object to use while sorting</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentWithCtorCollectionConfiguration`2.Named(System.String)">
            <summary>
            Specify a name of the parameter being configured
            </summary>
            <param name="name">name of parameter</param>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration">
            <summary>
            Configures a simple export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.#ctor(Grace.DependencyInjection.Impl.ConfigurableExportStrategy)">
            <summary>
            default constructor
            </summary>
            <param name="exportStrategy">export strategy to configure</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.WithPriority(System.Int32)">
            <summary>
            Defines the priority to export at
            </summary>
            <param name="priority">priority for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.WithKey(System.Object)">
            <summary>
            Export under a particular key
            </summary>
            <param name="key">key to associate with export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.As(System.Type)">
            <summary>
            Export as a particular type
            </summary>
            <param name="exportType">type to export as</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.As``1">
            <summary>
            Export as a particular type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Defines which environment this export should be exported in
            </summary>
            <param name="environment"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.AsName(System.String)">
            <summary>
            Export this type as a particular name
            </summary>
            <param name="name"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.AndSingleton">
            <summary>
            Export will be treated as a singleton for the lifetime of the container
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.AndSingletonPerScope">
            <summary>
            Export will be treated as a singleton for the lifetime of the scope
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.AndWeakSingleton">
            <summary>
            Exports will be trated as a singleton using a weak reference
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.ExternallyOwned">
            <summary>
            Mark the export as externally owned, doing so will absolve the container of having to call Dispose when done
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a custom Lifestyle container for export.
            </summary>
            <param name="lifestyle">Lifestyle container for the export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate">export condition delegate</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition">condition for export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName">metadata name</param>
            <param name="metadataValue">metadata value</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.EnrichWith(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Allows you to add custom activation logic to process before the object is returned.
            </summary>
            <param name="enrichWithDelegate"></param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FluentSimpleExportStrategyConfiguration.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncComparer`1">
            <summary>
            Comparer class that can be used to compare a particular property on a type of object
            </summary>
            <typeparam name="TItem">item type</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncComparer`1.#ctor(System.Func{`0,System.IComparable})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc">property access function</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncComparer`1.Compare(`0,`0)">
            <summary>
            Compare function
            </summary>
            <param name="x">x item</param>
            <param name="y">y item</param>
            <returns>int value representing which one if greater</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncExportStrategyInspector">
            <summary>
            Generic export strategy inspector
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategyInspector.#ctor(System.Action{Grace.DependencyInjection.IExportStrategy})">
            <summary>
            Default export strategy inspector
            </summary>
            <param name="inspectAction">inspect action</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategyInspector.Inspect(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Inspect export strategy
            </summary>
            <param name="exportStrategy">export strategy</param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IGenericExportStrategy">
            <summary>
            Inteface implemented by strategies that are open generic and can be closed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IGenericExportStrategy.CreateClosedStrategy(System.Type)">
            <summary>
            Creates a closed representation of the strategy.
            It returns null when it can't be support the requested type
            </summary>
            <param name="requestedType">type being requested</param>
            <returns>export strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericAttributeExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2">
            <summary>
            Creates a new instance of any class that implements ICollection(TItem)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.Equals(System.Object)">
            <summary>
            Override to compare 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.GetHashCode">
            <summary>
            Overriding because I'm overriding equals
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ICollectionExportStrategy`2.ExportNames">
            <summary>
            Export names for this collection
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1">
            <summary>
            This strategy takes a func and calls it when ever
            </summary>
            <typeparam name="T">type of instance that will be exported</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.#ctor(Grace.DependencyInjection.ExportFunction{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="instanceFunc">export func</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the strategy
            </summary>
            <param name="exportInjectionScope">export injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export strategy filter</param>
            <param name="locateKey"></param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceFuncStrategy`1.InternalActivate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            internal activate method
            </summary>
            <param name="injectionscope">injection scope</param>
            <param name="context">injection context</param>
            <returns>export instance</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2">
            <summary>
            Keyed locate delegate creates new locate delegate
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.ActivationType">
            <summary>
            Activation Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.ActivationName">
            <summary>
            Activation Name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.ExportNames">
            <summary>
            Export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.ExportTypes">
            <summary>
            Export types
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.DependsOn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.KeyedLocateDelegateStrategy`2.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.MetaStrategy`1">
            <summary>
            Strategy for creating a Meta&lt;T&gt;
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the meta strategy
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">context</param>
            <param name="consider">consider filter</param>
            <param name="locateKey"></param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.FindExportStrategy(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Find a matching export recursively up the chain
            </summary>
            <param name="exportInjectionScope">injection scope to check</param>
            <param name="context">context</param>
            <param name="consider">consider filter</param>
            <param name="locateKey">locatekey</param>
            <returns>strategy</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Meets conditions
            </summary>
            <param name="injectionContext">injection context</param>
            <returns>true</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.SecondaryStrategies">
            <summary>
            Secondary strategy
            </summary>
            <returns>empty</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.MetaStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            No enrichment
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.ActivationType">
            <summary>
            Activation type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.ActivationName">
            <summary>
            Activation name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.AllowingFiltering">
            <summary>
            allow filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Attributes">
            <summary>
            attributes for export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.OwningScope">
            <summary>
            Owning scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Key">
            <summary>
            Key for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.ExportNames">
            <summary>
            export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.ExportTypes">
            <summary>
            export types for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Environment">
            <summary>
            Export environment for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Priority">
            <summary>
            Priority for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Lifestyle">
            <summary>
            lifestyle for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.HasConditions">
            <summary>
            conditions for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.ExternallyOwned">
            <summary>
            Externally owned is false
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.Metadata">
            <summary>
            MEtadata for strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.MetaStrategy`1.DependsOn">
            <summary>
            Depends on nothing
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.OpenGenericUtilities">
            <summary>
            Class contains helper method for working with open generic methods
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OpenGenericUtilities.CreateClosedExportTypeFromRequestingType(System.Type,System.Type)">
            <summary>
            Creates a closed type using the requested type parameters.
            it will return null if it's not possible
            </summary>
            <param name="exportedType"></param>
            <param name="requestedType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OpenGenericUtilities.DoesTypeMeetGenericConstraints(System.Type,System.Type)">
            <summary>
            A helper to check to see if a generic parameter type meets the specified constraints
            </summary>
            <param name="genericParameterType">The generic parameter type</param>
            <param name="exported">The type parameter on the exported class</param>
            <returns>True if the type meets the constraints, otherwise false</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OpenGenericUtilities.DoesTypeMeetGenericAttributes(System.Type,System.Type)">
            <summary>
            A helper method that checks to see if the type meets the applied constraints on the generic
            </summary>
            <param name="genericParameterType">
            The type parameter on the generic
            </param>
            <param name="exported">The type parameter on the exported class</param>
            <returns>True if the item meets the constraints on the generic, otherwise false</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OpenGenericUtilities.HasDefaultConstructor(System.Type)">
            <summary>
            Determines if the type has a default constructor
            </summary>
            <param name="type">The type to check</param>
            <returns>
            True if the item has a default constructor, otherwise false
            </returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PartiallyClosedGenericPriorityAugmenter">
            <summary>
            Increases the priority of partially closed generics
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PartiallyClosedGenericPriorityAugmenter.Inspect(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            increases the strategies priority based on the number of closed parameters it has
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PriorityAttributeInspector`1">
            <summary>
            Inspects an export strategy and 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PriorityAttributeInspector`1.Inspect(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Inspect the strategy for T type attributes
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.PropertyExportStrategy">
            <summary>
            Property Export exports a property from another IExportStrategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.#ctor(System.Reflection.PropertyInfo,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Default constructor
            </summary>
            <param name="property"></param>
            <param name="targetStrategy"></param>
            <param name="exportCondition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            If this strategy meets condition and the target target strategy meets condition
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.PropertyExportStrategy.BuildAccessor">
            <summary>
            Builds an accessor method 
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleExportStrategy">
            <summary>
            Export strategy that registers very quickly but doesn't support advanced features like 
            importing properties, method or specific values for constructor parameters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType">export type</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.Initialize">
            <summary>
            Initialize strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            activate the strategy
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">consider filter</param>
            <param name="locateKey"></param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.WithCtorParam(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds constructor parameter to the definition
            </summary>
            <param name="constructorParamInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleExportStrategy.GetCompiledInfo">
            <summary>
            Gets the CompiledExportDelegateInfo definition for this export
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.SimpleExportStrategy.DependsOn">
            <summary>
            Depends on strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy">
            <summary>
            Represents an simple open generic export that can be closed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType">open type to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Cannot activate this strategy, you must create a closed strategy
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleGenericExportStrategy.CreateClosedStrategy(System.Type)">
            <summary>
            Creates a new closed export strategy that can be activated
            </summary>
            <param name="requestingType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IPerRequestScopeProvider">
            <summary>
            This interface is used by per request singleton container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IPerRequestScopeProvider.ProvideInjectionScope">
            <summary>
            Provide a scope
            </summary>
            <returns>returns a scope</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportsThatConfiguration">
            <summary>
            Configuration for ExportsThat, build a 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType">attribute type</param>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute">attribute type</typeparam>
            <param name="attributeFilter">attribute filter func</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Provide export filter that returns true when a type has an attribute that matches the provided type filter
            </summary>
            <param name="consider">type filter (TypesThat will work here)</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.HaveMetadata(System.String,System.Object)">
            <summary>
            Creates a new filter that returns true when metadata matches
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">string to compare Type name to</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.Activate(System.Func{System.Type,System.Boolean})">
            <summary>
            Creates a new export filter based on the type being activated
            </summary>
            <param name="activateFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace">namespace the type should be in</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type">class to check for</param>
            <param name="includeSubnamespaces">include sub namespaces</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T">class to check for</typeparam>
            <param name="includeSubnamespaces">include sub namespace</param>
            <returns>export configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreExportedAs``1">
            <summary>
            Creates a new filter that selects only exports that exoprt as a particular interface
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreExportedAs(System.Type)">
            <summary>
            Creates a new filter that selects only exports that exoprt as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreExportedAs(System.Func{System.Type,System.Boolean})">
            <summary>
            Creates a new filter that checks to see if it's exported type meets the criteria
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreExportedAsName(System.String)">
            <summary>
            Is the strategy exported as a particular name
            </summary>
            <param name="exportName">export name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.AreExportedAsName(System.Func{System.String,System.Boolean})">
            <summary>
            Is the strategy exported as a particular name
            </summary>
            <param name="exportFilter">export filter</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.Match(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Adds a export strategy filter
            </summary>
            <param name="exportFilter">export strategy filter</param>
            <returns>export strategy filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportsThatConfiguration.op_Implicit(Grace.DependencyInjection.Impl.ExportsThatConfiguration)~Grace.DependencyInjection.ExportStrategyFilter">
            <summary>
            Converts the configuration to a filter automatically
            </summary>
            <param name="configuration">configuration object</param>
            <returns>new filter method</returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportsThatConfiguration.Or">
            <summary>
            Use or logic instead of and
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportsThatConfiguration.And">
            <summary>
            Use and logic, this is the default
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.IMissingExportHandler">
            <summary>
            This interface is an internal interface that is used to tell the scope that there is a missing
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.IMissingExportHandler.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <param name="locateKey"></param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator">
            <summary>
            This class is a simple secondary resolver implementation
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ISecondaryExportLocator">
            <summary>
            Classes that wish to participate in resolving unknown exports can implement this interface.
            If an export can't be located in a scope a secondary dependency resolvers will be called
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.CanLocate(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Can locate a type
            </summary>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name being resolved</param>
            <param name="resolveType">type being resolved</param>
            <param name="consider">filter to use while resolving</param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.ISecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            LocateAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope">the scope that the locate came through</param>
            <param name="context">injection context for the locate</param>
            <param name="resolveName">name of the export being resolved</param>
            <param name="resolveType">type that is being resolved</param>
            <param name="collectionEmpty">value saying if there are already values in the collection</param>
            <param name="consider">filter to use while locating</param>
            <param name="locateKey"></param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Default constructor
            </summary>
            <param name="initValues"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.CanLocate(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Can locate a type
            </summary>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.Locate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Resolve will be called when the injection scope can't locate a particular resource
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.LocateAll(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Boolean,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            ResolveAll will be called every time a collection is resolved
            </summary>
            <param name="owningScope"></param>
            <param name="context"></param>
            <param name="resolveName"></param>
            <param name="resolveType"></param>
            <param name="collectionEmpty"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue(System.String,System.Object)">
            <summary>
            Adds a resolve value but name
            </summary>
            <param name="resolveName"></param>
            <param name="resolveValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.SimpleSecondaryExportLocator.AddResolveValue``1(System.String,System.Func{``0})">
            <summary>
            Adds a value to the resolver
            </summary>
            <typeparam name="T"></typeparam>
            <param name="resolveName"></param>
            <param name="resolveFunc"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IConfigurationModule">
            <summary>
            Classes that implement this method can be used to configure a registration scope or container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IConfigurationModule.Configure(Grace.DependencyInjection.IExportRegistrationBlock)">
            <summary>
            Called by the injection scope to add exports to the scope
            </summary>
            <param name="registrationBlock"></param>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScopeProvider">
            <summary>
            Provides disposal scopes for an IInjectionScope
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScopeProvider.ProvideDisposalScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Provides a default disposal scope, otherwise the current IInjectionScope will be used
            </summary>
            <param name="injectionScope"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1">
            <summary>
            This interface allows you to configure an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsKeyed``2(``1)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <typeparam name="TExportType">export type</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <param name="exportType">type to export under</param>
            <param name="key">export key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            You can provide a cleanup method to be called 
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Specify a lifestyle to use with the export
            </summary>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.IFluentExportInstanceConfiguration`1.Lifestyle">
            <summary>
            Configure the export lifestyle
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportRegistrationBlock">
            <summary>
            This interface allows you to register exports.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type">type to export</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export``1">
            <summary>
            Export a class by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Export an enumeration of types all at one time
            </summary>
            <param name="types">collection of types to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register types from an assembly for exports.
            </summary>
            <param name="assembly">assembly to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssemblyContaining``1">
            <summary>
            Register types from an assembly containing a particular type
            </summary>
            <typeparam name="T">type in assembly you want to export</typeparam>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register types from a set of assemblies.
            </summary>
            <param name="assemblies">list of assemblies to export</param>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">instance type</typeparam>
            <param name="instance">instance to export</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="instanceFunction">Func that creates instance</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function, it allows you to import properties, import method and activate methods
            of the T returned by the Func, if you don't need this functionality I recommend using ExportInstance
            </summary>
            <typeparam name="T">type to export</typeparam>
            <param name="exportFunction">Function to create instance of T</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.SimpleExport``1">
            <summary>
            Simple export allows you to export a type with a smaller set of options.
            This method should be used to register types in child containers because the registration process is
            much faster than Export and ExportFunc (though the fastest registeration option is still ExportInstance)
            </summary>
            <typeparam name="T">type to export</typeparam>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.SimpleExport(System.Type)">
            <summary>
            Simple export allows you to export a type with a smaller set of options.
            This method should be used to register types in child containers because the registration process is
            much faster than Export and ExportFunc (though the fastest registeration option is still ExportInstance)
            </summary>
            <param name="type">export type</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy">new startegy</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddExportProvider(Grace.DependencyInjection.IExportStrategyProvider)">
            <summary>
            Using this the developer can provide C# extensions that add to the registration block
            </summary>
            <param name="strategyProvider">new strategy provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportRegistrationBlock.AddInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Adds an inspector to this registration block
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDependencyInjectionContainer">
            <summary>
            This interface defines the base functionality for the container
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IDisposalScope">
            <summary>
            Defines a scope for injection that will dispose any objects added to it
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="registrationDelegate">delegate to be used to configure the scope</param>
            <param name="scopeName">scope name to configure</param>
        </member>
        <member name="M:Grace.DependencyInjection.IDependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule">configuration module object to be used configure the scope</param>
            <param name="scopeName">name of scope to configure</param>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IDependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.IDependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            Handling this event allows you to add exports to the container when an export can't be located.
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IExportStrategyCollection">
            <summary>
            Represents a collection of export strategies for a particular export name
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T">type to locate</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <param name="locateKey"></param>
            <returns>list of exports</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAllLazy``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate all instances of type as Meta(T)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TLazy"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAllOwned``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate all instances of type as Meta(T)
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TOwned"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.ActivateAllMeta``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate all instances of type as Meta(T)
            </summary>
            <typeparam name="TMeta"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.Activate(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName">export name</param>
            <param name="typeWrapper"></param>
            <param name="injectionContext">injection context</param>
            <param name="filter">export filter</param>
            <param name="locateKey"></param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy,System.Object)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy">new export strategy</param>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.IExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy,System.Object)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy">old export strategy</param>
            <param name="key"></param>
        </member>
        <member name="P:Grace.DependencyInjection.IExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionScope">
            <summary>
            IInjectionScope represents a scope for injection that can be created and inherited from at any time
            Note: The implementation for IInjectionScope is thread safe. 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionScope.MissingExportStrategyProviders">
            <summary>
            List of missing exports providers
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.IInjectionTargetInfo">
            <summary>
            Defines properties that are specific to the property that is being imported
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes on the Constructor, Method, or Property being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.LocateName">
            <summary>
            Locate name being used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.IInjectionTargetInfo.LocateType">
            <summary>
            Locate type being used
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ArrayExportStrategy`1">
            <summary>
            Creates a new array export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the array
            </summary>
            <param name="exportInjectionScope">injection scope that this activation is associated with</param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Doesn't allow for enrichment
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Equals(System.Object)">
            <summary>
            Overriding equals so multiple instances of Array
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.GetHashCode">
            <summary>
            Gets the hashcode for the object
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.DependsOn">
            <summary>
            Depends on nothing
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ArrayExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo">
            <summary>
            Represents the information needed to build a compiled delegate
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddConstructorParamInfo(Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo)">
            <summary>
            Adds a constructor parameter info
            </summary>
            <param name="paramInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperty(Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo)">
            <summary>
            Imports a property for the export
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethod(Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo)">
            <summary>
            Mark a method for importing 
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivateMethod(System.Reflection.MethodInfo)">
            <summary>
            Mark a method to be called during activation
            </summary>
            <param name="methodInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Add an enrich with delegate to the strategy
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichmentExpressionProvider(Grace.DependencyInjection.ICustomEnrichmentLinqExpressionProvider)">
            <summary>
            Add a custom enrichment expression provider
            </summary>
            <param name="provider">expression provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.SetImportConstructor(System.Reflection.ConstructorInfo)">
            <summary>
            Sets the constructor info for the export
            </summary>
            <param name="constructorInfo"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.AddCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Adds new cleanup delegate 
            </summary>
            <param name="newCleanupDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.Attributes">
            <summary>
            Attributes associated with the export type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.IsTransient">
            <summary>
            Is this export transient
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.InNewContext">
            <summary>
            Create new context before injecting
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.TrackDisposable">
            <summary>
            Track the export if disposable
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationType">
            <summary>
            This is the type that is being activated can be interface
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.CleanupDelegate">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportProperties">
            <summary>
            List of properties to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportMethods">
            <summary>
            List of methods to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ImportConstructor">
            <summary>
            Constructor to use for importing, can be null
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ConstructorParams">
            <summary>
            List of constructor arguements
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.ActivationMethodInfos">
            <summary>
            List of activation methods 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichmentDelegates">
            <summary>
            List of enrichment delegates to apply to the export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.EnrichmentExpressionProviders">
            <summary>
            Get a list of enrichment expression providers
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.CompiledExportDelegateInfo.CustomConstructorEnrichment">
            <summary>
            Custom constructor enrichment
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo">
            <summary>
            Information on how to import a method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.AddMethodParamInfo(Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo)">
            <summary>
            Add a method parameter
            </summary>
            <param name="methodParamInfo"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.AfterConstruction">
            <summary>
            After construction
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.MethodToImport">
            <summary>
            Import the method
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportMethodInfo.MethodParamInfos">
            <summary>
            List of method params for the import
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo">
            <summary>
            Information on how to import method parameter
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.AfterConstruction">
            <summary>
            After construction
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.ParameterName">
            <summary>
            parameter name being configured
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.ParameterType">
            <summary>
            paraeter type being configured
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.Filter">
            <summary>
            export filter
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.Comparer">
            <summary>
            Comparer object
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.IsRequired">
            <summary>
            Is required when exporting
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.ImportName">
            <summary>
            Import name 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.ValueProvider">
            <summary>
            Value provider for the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.MethodParamInfo.LocateKey">
            <summary>
            Locate key
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo">
            <summary>
            Information on how to import a property
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.Property">
            <summary>
            Property to import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ValueProvider">
            <summary>
            Value provider for the import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.LocateKey">
            <summary>
            Locate key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.ComparerObject">
            <summary>
            IComparer(T) to be used to sort collections
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ImportPropertyInfo.AfterConstruction">
            <summary>
            Import the property after construction
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo">
            <summary>
            Information about a constructor arguement
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterName">
            <summary>
            Name of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ParameterType">
            <summary>
            Type of the arguement 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ImportName">
            <summary>
            Import name to use if not importing by type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.IsRequired">
            <summary>
            Is the import required
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ValueProvider">
            <summary>
            The value provider
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ExportStrategyFilter">
            <summary>
            Export filter associated with this import
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.LocateKeyProvider">
            <summary>
            Locate key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledExport.ConstructorParamInfo.ComparerObject">
            <summary>
            IComparer(T) to use to compare export values
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.BlackList">
            <summary>
            Represents a list of exports that should be black listed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.GetEnumerator">
            <summary>
            returns a list of class names that are black listed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.String)">
            <summary>
            adds a new name to the black list
            </summary>
            <param name="blackedOut"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.Add(System.Type)">
            <summary>
            Add a new type to black list
            </summary>
            <param name="blackOutType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.BlackList.IsExportStrategyBlackedOut(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Checks to see if an export strategy is on the black list.
            </summary>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1">
            <summary>
            This export takes an activation delegate and creates a linq compiled expression
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.#ctor(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="exportActivationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.CompiledFuncExportStrategy`1.DependsOn">
            <summary>
            List of dependencies for this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DisposalScope">
            <summary>
            Represents a disposal scope
            </summary>
        </member>
        <member name="F:Grace.DependencyInjection.Impl.DisposalScope.disposed">
            <summary>
            true if the object has already been disposed
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add and object to the scope for disposal
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove the object from the scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DisposalScope.TrackedDisposables">
            <summary>
            Returns a list of all objects being tracked
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException">
            <summary>
            This exception is thrown when an IDisposable object is requested and no disposal scope is present.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.#ctor(System.Type,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default Constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionContext"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.#ctor(Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Default Constructor
            </summary>
            <param name="activationType"></param>
            <param name="injectionContext"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.ActivationType">
            <summary>
            Type that was being activated
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Exceptions.DisposalScopeMissingException.Message">
            <summary>
            Message for exception
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1">
            <summary>
            Configures an instance for export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.#ctor(Grace.DependencyInjection.Impl.IConfigurableExportStrategy)">
            <summary>
            Default Constructor
            </summary>
            <param name="exportStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithPriority(System.Int32)">
            <summary>
            Export the type with the specified priority
            </summary>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As``1">
            <summary>
            Export as a specific type (usually an interface)
            </summary>
            <typeparam name="TExportType"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.As(System.Type)">
            <summary>
            Export as a particular interface
            </summary>
            <param name="exportType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AsKeyed``2(``1)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <typeparam name="TExportType">export type</typeparam>
            <typeparam name="TKey">type of key</typeparam>
            <param name="key">key to export under</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AsKeyed(System.Type,System.Object)">
            <summary>
            Export this type as particular type under the specified key
            </summary>
            <param name="exportType">type to export under</param>
            <param name="key">export key</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.InEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Export type in this Environment (ExportEnvironement is a flag so it can be or'd)
            </summary>
            <param name="environment"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AsName(System.String)">
            <summary>
            Export the type under the specified name
            </summary>
            <param name="name">name to export under</param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.When(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.Unless(Grace.DependencyInjection.ExportConditionDelegate)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="conditionDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.AndCondition(Grace.DependencyInjection.Conditions.IExportCondition)">
            <summary>
            Adds a condition to the export
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenInjectedInto``1">
            <summary>
            Applies a new WhenInjectedInto condition on the export, using the export only when injecting into the specified class
            </summary>
            <typeparam name="TInjected"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenClassHas``1">
            <summary>
            Applies a WhenClassHas condition, using the export only if injecting into a class that is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenMemberHas``1">
            <summary>
            Applies a WhenMemberHas condition, using the export only if the Property or method or constructor is attribute with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WhenTargetHas``1">
            <summary>
            Applies a WhenTargetHas condition, using the export only if the Property or Parameter is attributed with TAttr
            </summary>
            <typeparam name="TAttr"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.WithMetadata(System.String,System.Object)">
            <summary>
            Adds metadata to an export
            </summary>
            <param name="metadataName"></param>
            <param name="metadataValue"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.DisposalCleanupDelegate(Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            
            </summary>
            <param name="disposalCleanupDelegate"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.UsingLifestyle(Grace.DependencyInjection.Lifestyle.ILifestyle)">
            <summary>
            Sets the export strategy 
            </summary>
            <param name="lifestyle"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportInstanceConfiguration`1.Lifestyle">
            <summary>
            Configure the export lifestyle
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportRegistrationBlock">
            <summary>
            This class implements the IExportRegistrationBlock interface and provides exports for IInjectionScope
            Note: this class is not thread safe. You can call configure from multiple threads on the same scope
            but you can not call from multiple threads to the same instance of a registration block
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor
            </summary>
            <param name="owningScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Type)">
            <summary>
            Register an export by it's type. This is required when dealing with open generics
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export``1">
            <summary>
            Register an export by it's type. This method allows you to specify things using linq expressions
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.Export(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Register a collection of types all at one time
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssembly(System.Reflection.Assembly)">
            <summary>
            Register an assembly for exports. You can perform any of these
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssemblyContaining``1">
            <summary>
            Register types from an assembly containing a particular type
            </summary>
            <typeparam name="T">type in assembly you want to export</typeparam>
            <returns>set configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Register a set of assemblies.
            </summary>
            <param name="assemblies"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(``0)">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportInstance``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Export an instance of an object for a particular set of interfaces
            </summary>
            <typeparam name="T"></typeparam>
            <param name="instanceFunction"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.ExportFunc``1(Grace.DependencyInjection.ExportFunction{``0})">
            <summary>
            Register an export function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="exportFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddExportStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Add an export strategy directly to a scope
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddExportProvider(Grace.DependencyInjection.IExportStrategyProvider)">
            <summary>
            Using this the developer can provide C# extensions that add to the registration block
            </summary>
            <param name="strategyProvider">new strategy provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.AddInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Adds an inspector to this registration block
            </summary>
            <param name="inspector">inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.GetExportStrategies">
            <summary>
            Get all exports for the registration block
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportRegistrationBlock.FilterOutBasedOnEnvironment(Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            Filter out strategies that are exported for particular environments
            </summary>
            <param name="strategyEnvironment"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportRegistrationBlock.OwningScope">
            <summary>
            Scope this registration block is for
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyListProvider">
            <summary>
            List of export strategies that can act as a IExportStrategyProvider
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyListProvider.ProvideStrategies">
            <summary>
            Provide a list of strategies
            </summary>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncExportStrategy`1">
            <summary>
            This export strategy creates a new Func(T) that calls the current scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Dispose">
            <summary>
            Dispose the func export, nothing to do
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Adds an enrich with delegate to the pipeline
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.AllowingFiltering">
            <summary>
            Allows filter of strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.DependsOn">
            <summary>
            Doesn't depend on anything to construct
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.FuncExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.#ctor(System.Func{`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.#ctor(System.Func{Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Constructor takes a Func(IInjectionScope, IInjectionContext, T)
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1">
            <summary>
            A value provider that calls a func to generate it's export
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.#ctor(System.Func{Grace.DependencyInjection.IInjectionContext,`0})">
            <summary>
            Default constructor
            </summary>
            <param name="valueFunc"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.FuncWithContextValueProvider`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy">
            <summary>
            Base class for generic func exports
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Dispose">
            <summary>
            Dispose of strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Initialize">
            <summary>
            Initialize the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.SecondaryStrategies">
            <summary>
            An export can specify it's own strategy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.DependsOn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.BaseGenericFuncExportStrategy.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2">
            <summary>
            Export strategy that creates a Func(TIn, TOut)
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`2.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3">
            <summary>
            Export strategy that creates Func(TIn1, TIn2, Tout)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`3.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4">
            <summary>
            Export strategy that creates a Func(TIn1, Tin2, TIn3, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`4.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`5.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6">
            <summary>
            Creates a new Func(TIn1, TIn2, TIn3, TIn4, TIn5, TOut)
            </summary>
            <typeparam name="TIn1"></typeparam>
            <typeparam name="TIn2"></typeparam>
            <typeparam name="TIn3"></typeparam>
            <typeparam name="TIn4"></typeparam>
            <typeparam name="TIn5"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.ExportTypes">
            <summary>
            Type this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.DelegateFactory.GenericFuncExportStrategy`6.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.GenericExportStrategy">
            <summary>
            Represents a generic export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.#ctor(System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="exportType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.GenericExportStrategy.CreateClosedStrategy(System.Type)">
            <summary>
            Creates a new closed export strategy that can be activated
            </summary>
            <param name="requestedType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportPropertyInfo">
            <summary>
            Information to export a property on an object
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportPropertyInfo.AddExportType(System.Type)">
            <summary>
            Add a type to the export info
            </summary>
            <param name="exporType"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportPropertyInfo.AddExportName(System.String)">
            <summary>
            Add an export name to export property
            </summary>
            <param name="exportName"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.PropertyInfo">
            <summary>
            Property to export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportTypes">
            <summary>
            Export Type
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportNames">
            <summary>
            Export names
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportPropertyInfo.ExportCondition">
            <summary>
            Export Condition
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionTargetInfo">
            <summary>
            Represents the information about injecting a particular object into another
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionTargetInfo.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Attribute},System.Object,System.Collections.Generic.IEnumerable{System.Attribute},System.Collections.Generic.IEnumerable{System.Attribute},System.String,System.Type)">
            <summary>
            Default constructor
            </summary>
            <param name="injectionType">the type that is being injected into</param>
            <param name="injectionTypeAttributes">attributes on the type being injected</param>
            <param name="injectionTarget">the ParameterInfo or PropertyInfo being injected into</param>
            <param name="injectionTargetAttributes">attributes on the ParameterInfo or PropertyInfo</param>
            <param name="injectionMemberAttributes">attribute on the Method,Constructor, or Property</param>
            <param name="locateName">name used when locating</param>
            <param name="locateType">type used when locating</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionType">
            <summary>
            This is the type that is being injected into 
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTypeAttributes">
            <summary>
            These are the attributes for the class that it's being injected into
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTarget">
            <summary>
            The PropertyInfo or ParameterInfo that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetName">
            <summary>
            This is the property or parameter name being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetType">
            <summary>
            This the type for the Property or Parameter being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionTargetAttributes">
            <summary>
            Attributes associated with the target PropertyInfo or ParameterInfo that is provided
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.InjectionMemberAttributes">
            <summary>
            Attributes associated with Constructor, Property or Method that is being injected
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.LocateName">
            <summary>
            Locate name being used
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionTargetInfo.LocateType">
            <summary>
            Locate type being used
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InstanceStrategy`1">
            <summary>
            Instance strategy represents the export strategy for a particular export instance
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.#ctor(`0)">
            <summary>
            Default Constructor
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InstanceStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Return the instance
            </summary>
            <param name="exportInjectionScope">injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">export filter</param>
            <param name="locateKey"></param>
            <returns>export object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Exceptions.RootScopeCloneException">
            <summary>
            This exception is thrown when you attempt to clone an InjectionKernel that doesn't have a parent
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Exceptions.RootScopeCloneException.#ctor(System.String,System.Guid)">
            <summary>
            Default Constructor
            </summary>
            <param name="scopeName"></param>
            <param name="scopeId"></param>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.LazyExportStrategy`1">
            <summary>
            Export strategy creates a new Lazy(T)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Dispose">
            <summary>
            Dipose the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.SecondaryStrategies">
            <summary>
            No secondary strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            No enrichment
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.LazyExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.DependsOn">
            <summary>
            Doesn't depend on anything
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.LazyExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ListExportStrategy`1">
            <summary>
            Export Strategy for creating List(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Dispose">
            <summary>
            Dispose the Export strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.SecondaryStrategies">
            <summary>
            No secondary strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ListExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            No enrichment
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.DependsOn">
            <summary>
            no dependencies
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ListExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.OwnedStrategy`1">
            <summary>
            An export strategy for creating Owned(T) objects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope"></param>
            <param name="context"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Dispose">
            <summary>
            Dispose of the strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.SecondaryStrategies">
            <summary>
            No secondary strategies
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.OwnedStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            No enrichment supported
            </summary>
            <param name="enrichWithDelegate">enrichment</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExportTypes">
            <summary>
            Export types this strategy should
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.DependsOn">
            <summary>
            Doesn't depend on anything
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.OwnedStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1">
            <summary>
            Export strategy to create ReadOnlyCollection(T) objects
            </summary>
            <typeparam name="T">type to locate</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Activate(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the export
            </summary>
            <param name="exportInjectionScope">export injection scope</param>
            <param name="context">injection context</param>
            <param name="consider">consider filter</param>
            <param name="locateKey"></param>
            <returns>activated object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Dispose">
            <summary>
            Dispose strategy
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Initialize">
            <summary>
            Initialize the export, caled by the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.MeetsCondition(Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Does this export meet the conditions to be used
            </summary>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.SecondaryStrategies">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.EnrichWithDelegate(Grace.DependencyInjection.EnrichWithDelegate)">
            <summary>
            Enrichment delegate
            </summary>
            <param name="enrichWithDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Equals(System.Object)">
            <summary>
            Override equals to check if the export strategy is the same
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.GetHashCode">
            <summary>
            Override because of equals override
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationType">
            <summary>
            This is type that will be activated, can be used for filtering
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ActivationName">
            <summary>
            Usually the type.FullName, used for blacklisting purposes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.AllowingFiltering">
            <summary>
            When considering an export should it be filtered out.
            True by default, usually it's only false for special export types like Array ad List
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Attributes">
            <summary>
            Attributes associated with the export strategy. 
            Note: do not return null. Return an empty enumerable if there are none
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.OwningScope">
            <summary>
            The scope that owns this export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Key">
            <summary>
            Export Key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExportNames">
            <summary>
            Names this strategy should be known as.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExportTypes">
            <summary>
            Types this strategy should be known as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.KeyedExportTypes">
            <summary>
            List of keyed interface to export under
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Environment">
            <summary>
            What environement is this strategy being exported under.
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Priority">
            <summary>
            What export priority is this being exported as
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Lifestyle">
            <summary>
            ILifestyle associated with export
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.HasConditions">
            <summary>
            Does this export have any conditions, this is important when setting up the strategy
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.ExternallyOwned">
            <summary>
            Are the object produced by this export externally owned
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.DependsOn">
            <summary>
            doesn't depend on anything
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ReadOnlyCollectionExportStrategy`1.Metadata">
            <summary>
            Metadata associated with this strategy
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2">
            <summary>
            Combines two life styles to try the first then the second 
            </summary>
            <typeparam name="TMain"></typeparam>
            <typeparam name="TSecondary"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.#ctor(`0,`1)">
            <summary>
            Constructor takes two lifestyles
            </summary>
            <param name="main">main lifestyle</param>
            <param name="secondary">secondary lifestyle</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.HybridLifestyle`2.Transient">
            <summary>
            If true then the container will allow the dependencies to be located in down facing scopes
            otherwise they will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.DependencyInjectionContainer">
            <summary>
            This is the standard IDependencyInjectionContainer implementation
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.#ctor(Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Default Constructor
            </summary>
            <param name="environment">Environment that you want this container to operate in (RunTime, DesignTime, Or UnitTest</param>
            <param name="comparer">delegate that can be used to sort exports, if null is provided CompareExportStrategies will be used</param>
            <param name="disposalScopeProvider">allows you to provide a custom disposal scope provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExport(System.String)">
            <summary>
            Black lists a particular export (Fullname)
            </summary>
            <param name="exportType">full name of the type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.BlackListExportType(System.Type)">
            <summary>
            Black list a particular export by Type
            </summary>
            <param name="exportType">type to black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddStrategyInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="configurationModule"></param>
            <param name="scopeName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddMissingExportStrategyProvider(Grace.DependencyInjection.IMissingExportStrategyProvider)">
            <summary>
            Missing export strategy providers can provide a set of exports that can be used to resolve a satisfy an import
            </summary>
            <param name="exportStrategyProvider">export strategy provider</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            Add an object for disposal 
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate">logic that will be run directly before the object is disposed</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove an object from the disposal scope
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure a particular scope in the container
            </summary>
            <param name="scopeName">the name of the scope that is being configured</param>
            <param name="registrationDelegate">configuration delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <param name="withKey"></param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategyCollection(System.Type,System.Boolean)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportType"></param>
            <param name="createIfDoesntExist"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.GetStrategyCollection(System.String,System.Boolean)">
            <summary>
            Get the export collection by name
            </summary>
            <param name="exportName">export name</param>
            <param name="createIfDoesntExist"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Inject(System.Object,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Inject dependencies into a constructed object
            </summary>
            <param name="injectedObject">object to be injected</param>
            <param name="injectionContext">injection context</param>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate missing exports
            </summary>
            <param name="context">injection context</param>
            <param name="exportName">export name</param>
            <param name="exportType">export type</param>
            <param name="consider">export filter</param>
            <param name="locateKey"></param>
            <returns>export object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CompareExportStrategiesByName(Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            This method compares 2 export strategies by class name
            </summary>
            <param name="x">x compare object</param>
            <param name="y">y compare object</param>
            <param name="environment">environment to compare the strategies in</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.CompareExportStrategies(Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.IExportStrategy,Grace.DependencyInjection.ExportEnvironment)">
            <summary>
            This method compares 2 export strategies in a particular environment using ExportEnvironment attributes and ExportPriority attributes
            </summary>
            <param name="x">x compare object</param>
            <param name="y">y compare object</param>
            <param name="environment">environment to compare the strategies in</param>
            <returns>compare value</returns>
        </member>
        <member name="M:Grace.DependencyInjection.DependencyInjectionContainer.Dispose(System.Boolean)">
            <summary>
            dispose implementation
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.AutoRegisterUnknown">
            <summary>
            If a concrete type is requested and it is not registered an export strategy will be created.
            Note: It will be scanned for attributes
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.ThrowExceptions">
            <summary>
            If true exception will be thrown if a type can't be located, otherwise it will be caught and errors logged
            False by default
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.RootScope">
            <summary>
            The root scope for the container
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.ScopeName">
            <summary>
            Name of scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.ScopeId">
            <summary>
            Unique Scope Id
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.DependencyInjectionContainer.ResolveUnknownExports">
            <summary>
            By handling this event you can provide a value when no export was found
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.DependencyInjectionContainer.Inspectors">
            <summary>
            List of Injection Inspectors for the scope
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.ExportStrategyCollection">
            <summary>
            A collection of exports to be used for dependency resolution
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.#ctor(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.ExportEnvironment,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default Constructor
            </summary>
            <param name="injectionKernel"></param>
            <param name="environment"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Activate(System.String,Grace.Utilities.TypeWrapper,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate the first export strategy that meets conditions
            </summary>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.ActivateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Activate all instances of a type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="injectionContext"></param>
            <param name="filter"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.AddExport(Grace.DependencyInjection.IExportStrategy,System.Object)">
            <summary>
            Add an export strategy to the collection
            </summary>
            <param name="exportStrategy"></param>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.RemoveExport(Grace.DependencyInjection.IExportStrategy,System.Object)">
            <summary>
            Remove an export strategy from the collection
            </summary>
            <param name="exportStrategy"></param>
            <param name="key"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose">
            <summary>
            Dispose this collection of strategies
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Dispose(System.Boolean)">
            <summary>
            Dispose this collection strategies
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.ExportStrategyCollection.Clone(Grace.DependencyInjection.Impl.InjectionKernel)">
            <summary>
            Clone the collection
            </summary>
            <param name="injectionKernel"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.ExportStrategyCollection.ExportStrategies">
            <summary>
            A enumerable of export strategies
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernel">
            <summary>
            InjectionKernel keeps a collection of exports to be used for resolving dependencies.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.#ctor(Grace.DependencyInjection.Impl.InjectionKernelManager,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,System.String,Grace.DependencyInjection.ExportStrategyComparer)">
            <summary>
            Default constructor
            </summary>
            <param name="kernelManager">kernel manager for this kernel</param>
            <param name="parentScope"></param>
            <param name="scopeProvider">passing a null for scope provider is ok</param>
            <param name="scopeName"></param>
            <param name="comparer"></param>	
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddMissingExportStrategyProvider(Grace.DependencyInjection.IMissingExportStrategyProvider)">
            <summary>
            Adds a missing export strategy provider to the scope
            </summary>
            <param name="exportStrategyProvider"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName"></param>
            <param name="registrationDelegate"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule"></param>
            <param name="disposalScopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the injection scope
            </summary>
            <param name="newLocator"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddStrategyInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Clone(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Clone the injection kernel, the rootscope cannot be cloned
            </summary>
            <param name="parentScope"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            You can add extra configuration to the scope
            </summary>
            <param name="registrationDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            Configure the scope with a configuration module
            </summary>
            <param name="configurationModule"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context associated with this scope
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="comparer"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <param name="comparer1"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetAllStrategies(Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Returns a list of all known strategies.
            </summary>
            <param name="exportFilter"></param>
            <returns>returns all known strategies</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategyCollection(System.Type,System.Boolean)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportType">type to locate</param>
            <param name="createIfDoesntExist"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.GetStrategyCollection(System.String,System.Boolean)">
            <summary>
            Finds a collection by export name
            </summary>
            <param name="exportName"></param>
            <param name="createIfDoesntExist"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Inject(System.Object,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Inject dependencies into a constructed object
            </summary>
            <param name="injectedObject">object to be injected</param>
            <param name="injectionContext">injection context</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateMissingExport(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate missing exports, this is an internal method
            </summary>
            <param name="context"></param>
            <param name="exportName"></param>
            <param name="exportType"></param>
            <param name="consider"></param>
            <param name="locateKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.ImportTypeByName(System.Type)">
            <summary>
            True if the type should be imported by name rather than type
            </summary>
            <param name="importType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.Dispose(System.Boolean)">
            <summary>
            Dispose of this kernel and child kernels
            </summary>
            <param name="dispose"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateListOfLazyExports``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.List{``0})">
            <summary>
            Locates a list of Lazy&lt;T&gt;
            </summary>
            <typeparam name="TLazy">type of lazy T</typeparam>
            <typeparam name="T">type to resolve</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="exportFilter">export filter to apply</param>
            <param name="locateKey"></param>
            <param name="returnList">return list</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateListOfOwnedExports``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.List{``0})">
            <summary>
            Locates a list of Owned&lt;T&gt;
            </summary>
            <typeparam name="TOwned">type of owned T</typeparam>
            <typeparam name="T">type to located</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="exportFilter">export filter to apply</param>
            <param name="locateKey"></param>
            <param name="returnList">list to return</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernel.LocateListOfMetaExports``2(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.List{``0})">
            <summary>
            Locate a list of Meta&lt;T&gt;
            </summary>
            <typeparam name="TMeta">type of meta object</typeparam>
            <typeparam name="T">type to locate</typeparam>
            <param name="injectionContext">injection context</param>
            <param name="exportFilter">export filter</param>
            <param name="locateKey"></param>
            <param name="returnList">list to populate</param>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Container">
            <summary>
            The container this scope was created in
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.ParentScope">
            <summary>
            Parent scope, can be null if it's the root scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.MissingExportStrategyProviders">
            <summary>
            List of missing exports providers
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Inspectors">
            <summary>
            List of Injection Inspectors for the scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernel.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.InjectionKernelManager">
            <summary>
            This class creates all injection kernels and contains all the configuration for all kernels
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.#ctor(Grace.DependencyInjection.DependencyInjectionContainer,Grace.DependencyInjection.ExportStrategyComparer,Grace.DependencyInjection.Impl.BlackList)">
            <summary>
            Default constructor
            </summary>
            <param name="container">container for the kernel manager</param>
            <param name="comparer">used to compare to export strategies for which one should be used</param>
            <param name="blackList">export strategy black list</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.SetRootScope(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            This method must be called before you configure any named kernels
            </summary>
            <param name="newRootScope"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.Configure(System.String,Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            Allows you to configure a base kernel of a particular name
            </summary>
            <param name="kernelName">name of the kernel being configured</param>
            <param name="registrationDelegate">registration delegate to call configure with</param>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.InjectionKernelManager.CreateNewKernel(Grace.DependencyInjection.Impl.InjectionKernel,System.String,Grace.DependencyInjection.ExportRegistrationDelegate,Grace.DependencyInjection.IDisposalScopeProvider,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Create a new Kernel of a particular name
            </summary>
            <param name="parentKernel">the parent kernel</param>
            <param name="kernelName">name of the kernel to create</param>
            <param name="registrationDelegate"></param>
            <param name="parentScopeProvider"></param>
            <param name="scopeProvider"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.BlackList">
            <summary>
            Black list associated with this kernel manager
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.InjectionKernelManager.Container">
            <summary>
            Container this kernel manager is associated with
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.INotifyWhenDisposed">
            <summary>
            Objects that implement this interface will be listened to for disposing
            </summary>
        </member>
        <member name="E:Grace.DependencyInjection.Lifestyle.INotifyWhenDisposed.Disposed">
            <summary>
            Raised when the object is disposed
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.LifetimeScope">
            <summary>
            The intention of the lifetime scope is to act as a light weight container.
            It does not support adding new exports or locators too
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.#ctor(Grace.DependencyInjection.IInjectionScope,System.String)">
            <summary>
            Default lifetime scope
            </summary>
            <param name="parentLocator"></param>
            <param name="scopeName"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.CreateChildScope(Grace.DependencyInjection.ExportRegistrationDelegate,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="registrationDelegate">delegate used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope provider for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.CreateChildScope(Grace.DependencyInjection.IConfigurationModule,System.String,Grace.DependencyInjection.IDisposalScopeProvider)">
            <summary>
            Creates a child scope from this scope using a configuration module
            </summary>
            <param name="scopeName">name of the scope you want to create</param>
            <param name="configurationModule">configuration module used to configure the new child scope</param>
            <param name="disposalScopeProvider">new disposal scope for the child scope</param>
            <returns>new child scope</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.CreateContext(Grace.DependencyInjection.IDisposalScope)">
            <summary>
            Create an injection context
            </summary>
            <returns>new injection context</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Locate``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by type
            </summary>
            <param name="injectionContext">injection context for the locate</param>
            <param name="consider">filter to be used when locating</param>
            <param name="withKey"></param>
            <typeparam name="T">type to locate</typeparam>
            <returns>export T if found, other wise default(T)</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Locate(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an object by type
            </summary>
            <param name="objectType">type to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating export</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Locate(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Locate an export by name
            </summary>
            <param name="exportName">name of export to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <returns>export object if found, other wise null</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.LocateAll``1(Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{``0})">
            <summary>
            Locate all export of type T
            </summary>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer">used for sorting the imports when returning the list</param>
            <typeparam name="T">type to locate</typeparam>
            <returns>List of T, this will return an empty list if not exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.LocateAll(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate All exports by the name provided
            </summary>
            <param name="name">export name to locate</param>
            <param name="injectionContext">injection context to use while locating</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>List of objects, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.LocateAll(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object,System.Collections.Generic.IComparer{System.Object})">
            <summary>
            Locate all exports by type
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="consider">filter to use while locating</param>
            <param name="withKey"></param>
            <param name="comparer"></param>
            <returns>list of object, this will return an empty list if no exports are found</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategy(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategy(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter,System.Object)">
            <summary>
            Finds the best matching strategy exported by the name provided
            </summary>
            <param name="exportType">type to locate</param>
            <param name="injectionContext">injection context</param>
            <param name="exportFilter">export filter</param>
            <param name="withKey"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategies(System.String,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="name"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategies(System.Type,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.ExportStrategyFilter)">
            <summary>
            Get the list of exported strategies sorted by best option.
            </summary>
            <param name="exportType"></param>
            <param name="injectionContext"></param>
            <param name="exportFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategyCollection(System.Type,System.Boolean)">
            <summary>
            Get the export strategy collection
            </summary>
            <param name="exportType"></param>
            <param name="createIfDoesntExist"></param>
            <returns>can be null if nothing is registered by that name</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetStrategyCollection(System.String,System.Boolean)">
            <summary>
            Get the export collection by name
            </summary>
            <param name="exportName">export name</param>
            <param name="createIfDoesntExist"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.AddSecondaryLocator(Grace.DependencyInjection.ISecondaryExportLocator)">
            <summary>
            Adds a secondary resolver to the container.
            </summary>
            <param name="newLocator">new secondary locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.AddStrategyInspector(Grace.DependencyInjection.IExportStrategyInspector)">
            <summary>
            Add a strategy 
            </summary>
            <param name="inspector">strategy inspector</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Configure(Grace.DependencyInjection.ExportRegistrationDelegate)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="registrationDelegate">registration delegate used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Configure(Grace.DependencyInjection.IConfigurationModule)">
            <summary>
            This method can be used to configure the root scope of the container
            </summary>
            <param name="configurationModule">configuration module used to configure the locator</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.AddStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Adds a new strategy to the container
            </summary>
            <param name="addStrategy"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.RemoveStrategy(Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Allows the caller to remove a strategy from the container
            </summary>
            <param name="knownStrategy">strategy to remove</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.AddDisposable(System.IDisposable,Grace.DependencyInjection.BeforeDisposalCleanupDelegate)">
            <summary>
            adds disposable
            </summary>
            <param name="disposable"></param>
            <param name="cleanupDelegate"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.RemoveDisposable(System.IDisposable)">
            <summary>
            Remove disposalble
            </summary>
            <param name="disposable"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Inject(System.Object,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Inject dependencies into a constructed object
            </summary>
            <param name="injectedObject">object to be injected</param>
            <param name="injectionContext">injection context</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.GetExtraData(System.String)">
            <summary>
            Extra data associated with the injection request. 
            </summary>
            <param name="dataName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.SetExtraData(System.String,System.Object)">
            <summary>
            Sets extra data on the injection context
            </summary>
            <param name="dataName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.LifetimeScope.Dispose">
            <summary>
            Dispose of lifetime
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.ScopeId">
            <summary>
            Unique identifier for the instance of the injection scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.ScopeName">
            <summary>
            The scopes name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.SecondaryExportLocators">
            <summary>
            List of Export Locators
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.Environment">
            <summary>
            The environment for this scope (always inherited from the root scope)
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.Container">
            <summary>
            Container
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.ParentScope">
            <summary>
            Parent scope
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.LifetimeScope.MissingExportStrategyProviders">
            <summary>
            List of missing exports providers
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle">
            <summary>
            Singleton lifestyle per value
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle.#ctor(Grace.DependencyInjection.ExportActivationDelegate)">
            <summary>
            Default constructor
            </summary>
            <param name="valueDelegate">value delegate</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle.Dispose">
            <summary>
            Dispose lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Locate object
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle.Clone">
            <summary>
            Clone lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerValueLifestyle.Transient">
            <summary>
            Returns false
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider">
            <summary>
            This interface is used by the SingletonPerRequestContainer
            It is used to provide a per request Lifestyle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.IPerRequestLifestyleProvider.ProvideContainer">
            <summary>
            Called to provide a new per request Lifestyle container
            </summary>
            <returns>new Lifestyle container</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonLifestyle">
            <summary>
            The SingletonContainer is a Lifestyle container that when used on an export makes it into a singleton
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Dispose">
            <summary>
            Dispose of the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.CreateInSingletonScope(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Creates an instance in a singleton scope
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle">
            <summary>
            Singleton per ancestor type
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.#ctor(System.Type,System.Object)">
            <summary>
            Default constructor
            </summary>
            <param name="ancestorType">type to locate</param>
            <param name="metadata">metadata to locate</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.#ctor(System.Type,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Default constructor
            </summary>
            <param name="ancestorType">type to locate</param>
            <param name="metadata">metadata to locate</param>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.Dispose">
            <summary>
            Dispose of the lifestyle
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            Locate export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.Clone">
            <summary>
            Clone lifestyle
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerAncestorLifestyle.Transient">
            <summary>
            Always transient
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle">
            <summary>
            Exports that use this will be shared per injection context and are considered transient
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerInjectionContextLifestyle.Transient">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle">
            <summary>
            Exports that use this will be shared per request
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.LocateContainer(Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext)">
            <summary>
            Locates an ILifestyle
            </summary>
            <param name="injectionScope"></param>
            <param name="injectionContext"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerRequestLifestyle.Transient">
            <summary>
            Singleton Per Request are considered transient when resolving
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle">
            <summary>
            This Lifestyle container will create an instance per scope instance.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Dispose">
            <summary>
            Dispose this Lifestyle container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.SingletonPerScopeLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle">
            <summary>
            Thread static container will share an export per thread
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Dispose">
            <summary>
            Dispose the container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.ThreadStaticLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle">
            <summary>
            The WeakSingletonContainer class will create an instance of the object and keep a weak reference to it
            A new instance will be requested upon request if the previous instance has been GC'd
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Dispose">
            <summary>
            Dispose of container
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Locate(Grace.DependencyInjection.ExportActivationDelegate,Grace.DependencyInjection.IInjectionScope,Grace.DependencyInjection.IInjectionContext,Grace.DependencyInjection.IExportStrategy)">
            <summary>
            This method is called by the export strategy when attempting to locate an export
            </summary>
            <param name="creationDelegate"></param>
            <param name="exportStrategyScope"></param>
            <param name="injectionContext"></param>
            <param name="exportStrategy"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Clone">
            <summary>
            This method is used to clone a Lifestyle container
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Lifestyle.WeakSingletonLifestyle.Transient">
            <summary>
            Objects managed by this container are transient. If true then the container will allow the export to be located in down facing scopes
            otherwise it will only be resolved in the current scope and in upward scopes (i.e. parent scope)
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Meta`1">
            <summary>
            Meta class is a wrapper around an export 
            </summary>
            <typeparam name="T">Type to request</typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Meta`1.#ctor(`0,Grace.DependencyInjection.IExportMetadata)">
            <summary>
            Default Constructor
            </summary>
            <param name="value">exported value</param>
            <param name="metadata">metadata associated with export</param>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Value">
            <summary>
            Resolved Value
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Meta`1.Metadata">
            <summary>
            Metadata for the resolved value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.Owned`1">
            <summary>
            THis class can be used to scope 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.DependencyInjection.Owned`1.SetValue(`0)">
            <summary>
            Sets the export value. It will only work once.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Grace.DependencyInjection.Owned`1.Value">
            <summary>
            The export value that is owned
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.ResolveUnknownExportArgs">
            <summary>
            This event arg can be handled to resolve unknown types.
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.ResolveUnknownExportArgs.#ctor(Grace.DependencyInjection.IInjectionContext,System.String,System.Type,System.Object)">
            <summary>
            CSTOR
            </summary>
            <param name="injectionContext"></param>
            <param name="requestedName"></param>
            <param name="requestedType"></param>
            <param name="locateKey"></param>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.InjectionContext">
            <summary>
            Injection context for the resolve request
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedName">
            <summary>
            The name of the export that was requested. Typically the full type name
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.RequestedType">
            <summary>
            The type that was requested, can be null if requested by name only
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.LocateKey">
            <summary>
            Locate key
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.ResolveUnknownExportArgs.ExportedValue">
            <summary>
            You can provide an export value
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.SortBy">
            <summary>
            Static class that provides IComparer(T) classes for sorting
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.SortBy.ProprtyAscending``2(System.Func{``0,``1})">
            <summary>
            Creates IComparer&lt;T&gt; for a specific property, ascending in order
            </summary>
            <typeparam name="T">Item type</typeparam>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">delegate that fetch TProp off of T</param>
            <returns>comparer</returns>
        </member>
        <member name="M:Grace.DependencyInjection.SortBy.ProprtyDecending``2(System.Func{``0,``1})">
            <summary>
            Creates IComparer&lt;T&gt; for a specific property, decending in order
            </summary>
            <typeparam name="T">Item type</typeparam>
            <typeparam name="TProp">property type</typeparam>
            <param name="propertyFunc">delegate that fetch TProp off of T</param>
            <returns>comparer</returns>
        </member>
        <member name="T:Grace.DependencyInjection.TypeFilterGroup">
            <summary>
            Groups together a set of type filters
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.#ctor(System.Func{System.Type,System.Boolean}[])">
            <summary>
            Default Constructor
            </summary>
            <param name="typeFilters"></param>
        </member>
        <member name="M:Grace.DependencyInjection.TypeFilterGroup.op_Implicit(Grace.DependencyInjection.TypeFilterGroup)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.TypeFilterGroup.UseOr">
            <summary>
            Or together the filters rather than And them
            </summary>
        </member>
        <member name="T:Grace.DependencyInjection.TypesThat">
            <summary>
            That class provides Type filter methods to be used in ExportInterfaces and SelectTypes method
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty``1(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <typeparam name="T">property type</typeparam>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveProperty(System.Type,System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyType">property type</param>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Provides a type filter for attributes, if true then the type will be used
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.Contains(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name contains the provided string
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn``1">
            <summary>
            Adds a type filter that returns true when a class is based on the specified type
            </summary>
            <typeparam name="T">based on type</typeparam>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn(System.Type)">
            <summary>
            Adds a type filter that returns true when a class is based on the specified type
            </summary>
            <param name="type">based on type</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreBasedOn(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter that filters a type based on it base type or interfaces
            </summary>
            <param name="typeFilter">type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.Match(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter
            </summary>
            <param name="matchFilter"></param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.ArePublic">
            <summary>
            Adds a type filter that returns true if the type is public
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreNotPublic">
            <summary>
            Adds a type filter that returns true if the type is private
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreConstructedGeneric">
            <summary>
            Adds a type filter that returns true if the type is constructed generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.TypesThat.AreOpenGeneric">
            <summary>
            Adds a type filter that returns true if the type is an open generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="T:Grace.DependencyInjection.Impl.TypesThatConfiguration">
            <summary>
            This is the configuration object for TypesThat, developers are not intended to use this
            it is an internal class for Grace
            </summary>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty``1(System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <typeparam name="T">property type</typeparam>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveProperty(System.Type,System.String)">
            <summary>
            Creates a type filter that returns true if a type has a particular property name
            </summary>
            <param name="propertyType">property type</param>
            <param name="propertyName">property name</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute(System.Type,System.Func{System.Attribute,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <param name="attributeType"></param>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute``1(System.Func{``0,System.Boolean})">
            <summary>
            Tests to see if a type has an attribute
            </summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="attributeFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.HaveAttribute(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds type filter that filters based uppon a classes attribute
            </summary>
            <param name="consider"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.StartWith(System.String)">
            <summary>
            Creates a new type filter method that returns true if the Name of the type starts with name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.EndWith(System.String)">
            <summary>
            Creates a new type filter that returns true if the Name ends with the provided string
            </summary>
            <param name="name">test string</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.Contains(System.String)">
            <summary>
            Creates a new type filter that returns true if the name contains the provided string
            </summary>
            <param name="name">string to test for</param>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespace(System.String,System.Boolean)">
            <summary>
            Creates a new type filter based on the types namespace
            </summary>
            <param name="namespace"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespaceAs(System.Type,System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <param name="type"></param>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreInTheSameNamespaceAs``1(System.Boolean)">
            <summary>
            Creates a new type filter that fiters based on if it's in the same namespace as another class
            </summary>
            <typeparam name="T"></typeparam>
            <param name="includeSubnamespaces"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn``1">
            <summary>
            Filters types based on a particular
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn(System.Type)">
            <summary>
            Filters types that are based on
            </summary>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreBasedOn(System.Func{System.Type,System.Boolean})">
            <summary>
            Allows you to provide a method that will test a classes base classes (base class and interfaces)
            </summary>
            <param name="typeFilter">based on type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.Match(System.Func{System.Type,System.Boolean})">
            <summary>
            Adds a type filter directly
            </summary>
            <param name="typeFilter">type filter</param>
            <returns>type filter</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.ArePublic">
            <summary>
            Adds a type filter that returns true if the type is public
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreNotPublic">
            <summary>
            Adds a type filter that returns true if the type is private
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreConstructedGeneric">
            <summary>
            Adds a type filter that returns true if the type is constructed generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.AreOpenGeneric">
            <summary>
            Adds a type filter that returns true if the type is an open generic
            </summary>
            <returns>configuration object</returns>
        </member>
        <member name="M:Grace.DependencyInjection.Impl.TypesThatConfiguration.op_Implicit(Grace.DependencyInjection.Impl.TypesThatConfiguration)~System.Func{System.Type,System.Boolean}">
            <summary>
            Automatically convert from TypefilterGroup to Func(Type,bool)
            </summary>
            <param name="configuration"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.Or">
            <summary>
            Or together the filters rather than using And
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.And">
            <summary>
            And together filters rather than using Or
            </summary>
        </member>
        <member name="P:Grace.DependencyInjection.Impl.TypesThatConfiguration.Not">
            <summary>
            Reverses the logic for the next type filter
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.DependencyInjectionContainerDiagnostic">
            <summary>
            Runs diagnostics on a dependency injection container
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.#ctor(Grace.DependencyInjection.IDependencyInjectionContainer)">
            <summary>
            Default constructor takes a DI container
            </summary>
            <param name="container">container to diagnose</param>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.Environment">
            <summary>
            Environment for the container
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.AutoRegisterUnknown">
            <summary>
            Auto register unknown concrete types
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.RootScope">
            <summary>
            RootScope for the container
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.Exports">
            <summary>
            Exports for the container
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.PossibleMissingDependencies">
            <summary>
            List of possible missing dependencies.
            Note: This is just a possible missing dependency
            Using static analysis this is a best attempt at resolving.
            Because of conditions and other factors it's possible to have no missing dependencies listed
            and still fail to resolve and vice versa
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.ExportsByName">
            <summary>
            All exports by name
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.DependencyInjectionContainerDiagnostic.ExportsByType">
            <summary>
            All export by type
            </summary>
        </member>
        <member name="T:Grace.Diagnostics.InjectionScopeDiagnostic">
            <summary>
            Provides diagnostic information about an IInjectionScope
            Used by visual studio for debugging
            </summary>
        </member>
        <member name="M:Grace.Diagnostics.InjectionScopeDiagnostic.#ctor(Grace.DependencyInjection.IInjectionScope)">
            <summary>
            Default constructor takes scope as only parameter
            </summary>
            <param name="injectionScope">injection scope to diagnose</param>
        </member>
        <member name="M:Grace.Diagnostics.InjectionScopeDiagnostic.CalculatePossibleMissingDependencies(Grace.DependencyInjection.IExportLocator)">
            <summary>
            Calculates a list of possible missing dependencies
            </summary>
            <param name="locator"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.Environment">
            <summary>
            Environment for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.ParentScope">
            <summary>
            Parent scope for injection scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.ScopeName">
            <summary>
            Name of scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.ScopeId">
            <summary>
            Unique Id for the scope
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.Exports">
            <summary>
            list of all exports
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.ExportsByName">
            <summary>
            Exported names
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.ExportsByType">
            <summary>
            Exported types
            </summary>
        </member>
        <member name="P:Grace.Diagnostics.InjectionScopeDiagnostic.PossibleMissingDependencies">
            <summary>
            List of possible missing dependencies
            Note: This is just a possible missing dependency
            Using static analysis this is a best attempt at resolving.
            Because of conditions and other factors it's possible to have no missing dependencies listed
            and still fail to resolve and vice versa
            </summary>
        </member>
        <member name="T:Grace.LanguageExtensions.DateTimeResolution">
            <summary>
            Date time resolution
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Millisecond">
            <summary>
            Equal to the millisecond
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Second">
            <summary>
            Equal to the second
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Minute">
            <summary>
            Equal to the minute
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Hour">
            <summary>
            Equal to the hour
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Date">
            <summary>
            Equal to the date
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Week">
            <summary>
            Equal to the same week
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Month">
            <summary>
            Equal to the month
            </summary>
        </member>
        <member name="F:Grace.LanguageExtensions.DateTimeResolution.Year">
            <summary>
            Equal to the year
            </summary>
        </member>
        <member name="T:Grace.LanguageExtensions.DateTimeExtensions">
            <summary>
            C# extension methods for DateTime
            </summary>
        </member>
        <member name="M:Grace.LanguageExtensions.DateTimeExtensions.IsEqualTo(System.DateTime,System.DateTime,Grace.LanguageExtensions.DateTimeResolution)">
            <summary>
            Compares two date time instances down to the millisecond
            </summary>
            <param name="dateTime"></param>
            <param name="compareDateTime"></param>
            <param name="resolution"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.LanguageExtensions.DateTimeExtensions.IsEqualTo(System.DateTime,System.Nullable{System.DateTime},Grace.LanguageExtensions.DateTimeResolution)">
            <summary>
            Compares two date time 
            </summary>
            <param name="dateTime"></param>
            <param name="compareDateTime"></param>
            <param name="resolution"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.LanguageExtensions.DateTimeExtensions.IsEqualTo(System.Nullable{System.DateTime},System.DateTime,Grace.LanguageExtensions.DateTimeResolution)">
            <summary>
            Compare two date times
            </summary>
            <param name="dateTime"></param>
            <param name="compareDateTime"></param>
            <param name="resolution"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.LanguageExtensions.DateTimeExtensions.IsEqualTo(System.Nullable{System.DateTime},System.Nullable{System.DateTime},Grace.LanguageExtensions.DateTimeResolution)">
            <summary>
            Compare two nullable datetime to a particular resolution
            </summary>
            <param name="dateTime"></param>
            <param name="compareDateTime"></param>
            <param name="resolution"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.LanguageExtensions.IEnumerableExtensions">
            <summary>
            Extensions for IEnumerable
            </summary>
        </member>
        <member name="M:Grace.LanguageExtensions.IEnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Apply an action to an IEnumerable
            </summary>
            <typeparam name="T">t type</typeparam>
            <param name="enumerable">enumerable</param>
            <param name="action">action to apply</param>
        </member>
        <member name="M:Grace.LanguageExtensions.IEnumerableExtensions.SortEnumerable``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Operates on an IEnumerable and creates a new IEnumerable that is sorted
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.LanguageExtensions.IEnumerableExtensions.ReverseEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Reverses an IEnumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLog">
            <summary>
            Logs all message to debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILog">
            <summary>
            an instance of a log
            </summary>
        </member>
        <member name="M:Grace.Logging.ILog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message">message to log</param>
            <param name="exp">exception to log</param>
        </member>
        <member name="M:Grace.Logging.ILog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format">format object</param>
            <param name="formatParameters">format parameters</param>
        </member>
        <member name="M:Grace.Logging.ILog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message">message to log</param>
            <param name="exp">exception to log</param>
        </member>
        <member name="M:Grace.Logging.ILog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format">format string</param>
            <param name="formatParameters">format parameters</param>
        </member>
        <member name="M:Grace.Logging.ILog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message">message to log</param>
            <param name="exp">exception to log</param>
        </member>
        <member name="M:Grace.Logging.ILog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format">format string</param>
            <param name="formatParameters">format parameters</param>
        </member>
        <member name="M:Grace.Logging.ILog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message">message to log</param>
            <param name="exp">exception to log</param>
        </member>
        <member name="M:Grace.Logging.ILog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format">format message</param>
            <param name="formatParameters">format parameters</param>
        </member>
        <member name="M:Grace.Logging.ILog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message">message to log</param>
            <param name="exp">exception to log</param>
        </member>
        <member name="M:Grace.Logging.ILog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format">format string</param>
            <param name="formatParameters">format parameters</param>
        </member>
        <member name="P:Grace.Logging.ILog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled
            </summary>
        </member>
        <member name="P:Grace.Logging.ILog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled
            </summary>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="logName"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Debug(System.Object,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Log a Debug formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Info(System.Object,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Log a Info formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Warn(System.Object,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Log a Warn formatted message
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Error(System.Object,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Log an Error format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.Fatal(System.Object,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Log an Fatal format
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsDebugEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsInfoEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsWarnEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsErrorEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Grace.Logging.DebugConsoleLog.IsFatalEnabled">
            <summary>
            Always true
            </summary>
        </member>
        <member name="T:Grace.Logging.DebugConsoleLogService">
            <summary>
            Log service that writes everything to the debug console
            </summary>
        </member>
        <member name="T:Grace.Logging.ILogService">
            <summary>
            Log service to be used by Logger
            </summary>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type">type of logger to get</param>
            <returns>ILog instance</returns>
        </member>
        <member name="M:Grace.Logging.ILogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name">logger name to get</param>
            <returns>ILog instance</returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DebugConsoleLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.DevNullLog">
            <summary>
            Logger that does nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Debug(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.DebugFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Info(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.InfoFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Warn(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.WarnFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Error(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.Fatal(System.Object,System.Exception)">
            <summary>
            Does nothing
            </summary>
            <param name="message"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.DevNullLog.FatalFormat(System.String,System.Object[])">
            <summary>
            Does nothing
            </summary>
            <param name="format"></param>
            <param name="formatParameters"></param>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsDebugEnabled">
            <summary>
            Is Debug Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsInfoEnabled">
            <summary>
            Is Info Log Level  Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsWarnEnabled">
            <summary>
            Is Warn Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsErrorEnabled">
            <summary>
            Is Error Log Level Enabled, always false
            </summary>
        </member>
        <member name="P:Grace.Logging.DevNullLog.IsFatalEnabled">
            <summary>
            Is Fatal Log Level Enabled, always false
            </summary>
        </member>
        <member name="T:Grace.Logging.DevNullLogService">
            <summary>
            Returns loggers that do nothing
            </summary>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.Type)">
            <summary>
            Get a log instance based on type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.DevNullLogService.GetLogger(System.String)">
            <summary>
            Get a log instance by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Logging.Logger">
            <summary>
            Static logging class for the framework. 
            </summary>
        </member>
        <member name="M:Grace.Logging.Logger.SetLogService(Grace.Logging.ILogService)">
            <summary>
            Set the logger to be used for the containers
            </summary>
            <param name="logService"></param>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.Type)">
            <summary>
            Get an ILog instance
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger``1">
            <summary>
            Get an ILog instance
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.GetLogger(System.String)">
            <summary>
            Get an ILog by name
            </summary>
            <param name="logName"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Logging.Logger.Debug(System.String,System.String,System.Exception)">
            <summary>
            Log a Debug message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Info(System.String,System.String,System.Exception)">
            <summary>
            Log a Info message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Warn(System.String,System.String,System.Exception)">
            <summary>
            Log a Warn message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Error(System.String,System.String,System.Exception)">
            <summary>
            Log an Error message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="M:Grace.Logging.Logger.Fatal(System.String,System.String,System.Exception)">
            <summary>
            Log an Fatal message
            </summary>
            <param name="message"></param>
            <param name="supplemental"></param>
            <param name="exp"></param>
        </member>
        <member name="P:Grace.Logging.Logger.LogService">
            <summary>
            Get the log service for the framework
            </summary>
        </member>
        <member name="T:Grace.Logging.LogLevel">
            <summary>
            Log Level enumeration
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Debug">
            <summary>
            Debug level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Info">
            <summary>
            Info Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Warn">
            <summary>
            Warn Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Error">
            <summary>
            Error Level
            </summary>
        </member>
        <member name="F:Grace.Logging.LogLevel.Fatal">
            <summary>
            Fatal Level
            </summary>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableHashTree`2">
            <summary>
            Immutable HashTree implementation http://en.wikipedia.org/wiki/AVL_tree
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Empty">
            <summary>
            Empty hashtree, used as the starting point 
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Hash">
            <summary>
            Hash value for this node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Height">
            <summary>
            Height of hashtree node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Key">
            <summary>
            Key value for this hash node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Value">
            <summary>
            Value for this hash node
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Conflicts">
            <summary>
            Keys with the same hashcode
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Left">
            <summary>
            Left node of the hash tree
            </summary>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableHashTree`2.Right">
            <summary>
            Right node of the hash tree
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.IterateInOrder(System.Action{`0,`1})">
            <summary>
            Provide an action that will be called for each node in the hash tree
            </summary>
            <param name="iterateAction"></param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.IterateInOrder">
            <summary>
            Return an enumerable of KVP
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.Add(`0,`1,Grace.Data.Immutable.ImmutableHashTree{`0,`1}.UpdateDelegate)">
            <summary>
            Adds a new entry to the hashtree
            </summary>
            <param name="key">key to add</param>
            <param name="value">value to add</param>
            <param name="updateDelegate">update delegate, by default will throw key already exits exception</param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.ContainsKey(`0)">
            <summary>
            Checks to see if a key is contained in the hashtable
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.TryGetValue(`0,`1@)">
            <summary>
            Try get value from hashtree
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableHashTree`2.GetEnumerator">
            <summary>
            Gets an enumerator for the immutable hash
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Keys">
            <summary>
            Returns all the keys in the hashtree
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Values">
            <summary>
            returns all the values in the hashtree
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.IsEmpty">
            <summary>
            Is the hash tree empty
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableHashTree`2.Count">
            <summary>
            Gets the count of the immutable hashtree. Note its faster to do a lookup than to do a count
            If you want to test for emptyness use the IsEmpty property
            </summary>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableHashTree`2.UpdateDelegate">
            <summary>
            Update delegate defines behavior when key already exists
            </summary>
            <param name="currentValue"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray">
            <summary>
            Immutable array create methods
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.Create``1(``0[])">
            <summary>
            Create an array 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.From``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a new immutable list from an IEnumerable(T)
            </summary>
            <typeparam name="T">item type</typeparam>
            <param name="list">list of T</param>
            <returns>immutable array</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray.From``1(``0[],System.Int32)">
            <summary>
            Create a new immutable array from an T[]
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ts"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray`1">
            <summary>
            Immutable List that implements IReadOnlyList(T)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Grace.Data.Immutable.ImmutableArray`1.Empty">
            <summary>
            Empty list
            </summary>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.GetEnumerator">
            <summary>
            Get an enumerator for this list
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get an enumerator for this list
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Contains(`0)">
            <summary>
            Contains specified value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy to array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.IndexOf(`0)">
            <summary>
            Index of item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Add(`0)">
            <summary>
            Add T to ImmutableList creating new list
            </summary>
            <param name="value">new T</param>
            <returns>new list</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add and IEnumerable to this list
            </summary>
            <param name="enumerable"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.AddRange(`0[])">
            <summary>
            Adds a range of T to immutable list creating a new one
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Explicit(`0[])~Grace.Data.Immutable.ImmutableArray{`0}">
            <summary>
            Implicit conversion from List(T)
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Explicit(Grace.Data.Immutable.ImmutableArray{`0})~`0[]">
            <summary>
            Implicit conversion to List(T)
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.GetHashCode">
            <summary>
            Get hashcode of array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)">
            <summary>
            Compare arrays
            </summary>
            <param name="other"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Equality(Grace.Data.Immutable.ImmutableArray{`0},Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>
            Equals override
            </summary>
            <param name="left">left side of statement</param>
            <param name="right">right side of statement</param>
            <returns>true if euqal</returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Inequality(Grace.Data.Immutable.ImmutableArray{`0},Grace.Data.Immutable.ImmutableArray{`0})">
            <summary>
            Not equal override
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Equality(System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}},System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}})">
            <summary>
            Equal override for nullable
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Data.Immutable.ImmutableArray`1.op_Inequality(System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}},System.Nullable{Grace.Data.Immutable.ImmutableArray{`0}})">
            <summary>
            Not equal override for nullable
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Count">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Length">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.IsReadOnly">
            <summary>
            Immutable list is always read only
            </summary>
        </member>
        <member name="P:Grace.Data.Immutable.ImmutableArray`1.Item(System.Int32)">
            <summary>
            Index into list
            </summary>
            <param name="index">index for list</param>
            <returns>T at index</returns>
        </member>
        <member name="T:Grace.Data.Immutable.ImmutableArray`1.ImmutableArrayEnumerator`1">
            <summary>
            Internal enumerator class used to enumerate lists, stacks and queues
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Grace.Utilities.MethodInfoWrapper">
            <summary>
            MethodInfo wrapper class
            </summary>
        </member>
        <member name="M:Grace.Utilities.MethodInfoWrapper.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Default Constructor
            </summary>
            <param name="methodInfo">method info to wrap</param>
        </member>
        <member name="M:Grace.Utilities.MethodInfoWrapper.op_Implicit(Grace.Utilities.MethodInfoWrapper)~System.Reflection.MethodInfo">
            <summary>
            Convert to method info
            </summary>
            <param name="wrapper">wrapper</param>
            <returns>method info</returns>
        </member>
        <member name="M:Grace.Utilities.MethodInfoWrapper.op_Implicit(System.Reflection.MethodInfo)~Grace.Utilities.MethodInfoWrapper">
            <summary>
            Convert to wrapped method info
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.MethodInfoWrapper.MethodInfo">
            <summary>
            Wrapped method info
            </summary>
        </member>
        <member name="T:Grace.Utilities.PropertyInfoWrapper">
            <summary>
            Wrapper class around PropertyInfo
            </summary>
        </member>
        <member name="M:Grace.Utilities.PropertyInfoWrapper.#ctor(System.Reflection.PropertyInfo)">
            <summary>
            Default constructor
            </summary>
            <param name="propertyInfo">property info to wrap</param>
        </member>
        <member name="M:Grace.Utilities.PropertyInfoWrapper.op_Implicit(Grace.Utilities.PropertyInfoWrapper)~System.Reflection.PropertyInfo">
            <summary>
            Convert to propery info
            </summary>
            <param name="wrapper">wrapped info</param>
            <returns>property info</returns>
        </member>
        <member name="M:Grace.Utilities.PropertyInfoWrapper.op_Implicit(System.Reflection.PropertyInfo)~Grace.Utilities.PropertyInfoWrapper">
            <summary>
            convert to wrapped property info
            </summary>
            <param name="propertyInfo">property info</param>
            <returns>wrapped property info</returns>
        </member>
        <member name="P:Grace.Utilities.PropertyInfoWrapper.PropertyInfo">
            <summary>
            Wrapped property info
            </summary>
        </member>
        <member name="T:Grace.Utilities.SafeDictionary`2">
            <summary>
            Safe dictionary class, lifted shamelessly from TinyIoC
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Try and get a key value pair from the dictionary
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Remove(`0)">
            <summary>
            Remove an entry from the dictionary
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Clear">
            <summary>
            Clear the dictionary
            </summary>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.Dispose">
            <summary>
            Dispose of the dictionary
            </summary>
        </member>
        <member name="M:Grace.Utilities.SafeDictionary`2.GetEnumerator">
            <summary>
            Get list of KVP
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.SafeDictionary`2.Item(`0)">
            <summary>
            Set a value into the dictionary
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.SafeDictionary`2.Keys">
            <summary>
            Keys in the dictionary
            </summary>
        </member>
        <member name="T:Grace.Utilities.SequentialGuidType">
            <summary>
            Specify which part of the guid you want to be sequential
            </summary>
        </member>
        <member name="F:Grace.Utilities.SequentialGuidType.SequentialAsString">
            <summary>
            Store as a string, useful for MySql
            </summary>
        </member>
        <member name="F:Grace.Utilities.SequentialGuidType.SequentialAsBinary">
            <summary>
            Store as a binary useful for MongoDB and any other DB that stores it UUID as a binary value
            </summary>
        </member>
        <member name="F:Grace.Utilities.SequentialGuidType.SequentialAtEnd">
            <summary>
            Store uniqueness at end useful for MSSQL as it uses the last 6 digits of the guid first
            </summary>
        </member>
        <member name="T:Grace.Utilities.SequentialGuid">
            <summary>
            This is a utility class for creating sequential guids down to the millisecond 
            </summary>
        </member>
        <member name="F:Grace.Utilities.SequentialGuid.DefaultType">
            <summary>
            Default Type of Guid to generate
            </summary>
        </member>
        <member name="M:Grace.Utilities.SequentialGuid.Next(System.Nullable{Grace.Utilities.SequentialGuidType})">
            <summary>
            Gets the next sequential guid, depending on where you are storing will dictate which type you want
            Note: When called within the same millisecond there is no guarntee it will be in sequence but it will be unique
            </summary>
            <param name="guidType"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Utilities.TaskHelper">
            <summary>
            Utility methods to help with creating tasks
            </summary>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.CreateEmptyTask">
            <summary>
            Creates a new empty task
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.NullTask``1">
            <summary>
            Creates a null task
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Grace.Utilities.TaskHelper.ReturnTask``1(``0)">
            <summary>
            Returns a value as a task
            </summary>
            <typeparam name="T"></typeparam>
            <param name="returnValue"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Utilities.TypeWrapper">
            <summary>
            This class exists to wrap an instance of Type when being passed as a parameter in Linq Expressions
            because some platforms don't support directly passing Type (I'm looking at you Windows 8.1)
            </summary>
        </member>
        <member name="M:Grace.Utilities.TypeWrapper.#ctor(System.Type)">
            <summary>
            default constructor
            </summary>
            <param name="type">type to wrap</param>
        </member>
        <member name="M:Grace.Utilities.TypeWrapper.op_Implicit(Grace.Utilities.TypeWrapper)~System.Type">
            <summary>
            Implicitly convert to a type
            </summary>
            <param name="wrapper">type wrapper</param>
            <returns>type</returns>
        </member>
        <member name="M:Grace.Utilities.TypeWrapper.op_Implicit(System.Type)~Grace.Utilities.TypeWrapper">
            <summary>
            implicitly converts from type to type wrapper
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.TypeWrapper.Type">
            <summary>
            wrapped type
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakAction">
            <summary>
            Represents a delegate that will not hold a reference to it's target
            </summary>
        </member>
        <member name="M:Grace.Utilities.WeakAction.#ctor(System.Action)">
            <summary>
            Default Action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Grace.Utilities.WeakAction.Invoke">
            <summary>
            Invoke the action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction.IsAlive">
            <summary>
            True if Target is alive
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction.MethodInfo">
            <summary>
            Method info for action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction.Target">
            <summary>
            Target object
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakAction`1">
            <summary>
            Weak Action&lt;T&gt;
            </summary>
            <typeparam name="T">action param</typeparam>
        </member>
        <member name="M:Grace.Utilities.WeakAction`1.#ctor(System.Action{`0})">
            <summary>
            Default Action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Grace.Utilities.WeakAction`1.Invoke(`0)">
            <summary>
            Invoke the action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction`1.IsAlive">
            <summary>
            True if Target is alive
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction`1.MethodInfo">
            <summary>
            Method info for action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakAction`1.Target">
            <summary>
            Target object
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakFunc`1">
            <summary>
            Represents a Func(T) that will not hold a reference to the target
            </summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.#ctor(System.Func{`0})">
            <summary>
            Default Constructor
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`1.Invoke">
            <summary>
            Invoke the Func
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`1.IsAlive">
            <summary>
            Is the target alive
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`1.MethodInfo">
            <summary>
            Method info for action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`1.Target">
            <summary>
            Target object
            </summary>
        </member>
        <member name="T:Grace.Utilities.WeakFunc`2">
            <summary>
            Represents a Func(T) that will not hold a reference to the target
            </summary>
            <typeparam name="TResult"></typeparam>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`2.#ctor(System.Func{`0,`1})">
            <summary>
            Default Constructor
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Grace.Utilities.WeakFunc`2.Invoke(`0)">
            <summary>
            Invoke the Func
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`2.IsAlive">
            <summary>
            Is the target alive
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`2.MethodInfo">
            <summary>
            Method info for action
            </summary>
        </member>
        <member name="P:Grace.Utilities.WeakFunc`2.Target">
            <summary>
            Target object
            </summary>
        </member>
        <member name="T:Grace.Validation.IAsyncValidationRule">
            <summary>
            asynchronous validation rule
            </summary>
        </member>
        <member name="T:Grace.Validation.IValidationRule">
            <summary>
            Represents a validation rule
            </summary>
        </member>
        <member name="M:Grace.Validation.IValidationRule.DependentProperties">
            <summary>
            Properties this rule depends on
            </summary>
            <returns></returns>
        </member>
        <member name="M:Grace.Validation.IValidationRule.Standards">
            <summary>
            Standards this rule is a part of
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Validation.IValidationRule.Namespace">
            <summary>
            Namespace the rule exists in
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRule.DisplayName">
            <summary>
            Display name for the rule
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRule.Name">
            <summary>
            Name for the rule
            </summary>
        </member>
        <member name="M:Grace.Validation.IAsyncValidationRule.Validate(Grace.Validation.IRuleExecutionContext)">
            <summary>
            Validate an object asynchronous
            </summary>
            <param name="ruleExecutionContext">execution context</param>
            <returns>task</returns>
        </member>
        <member name="T:Grace.Validation.IAttributeValidationRuleProvider">
            <summary>
            Provides validations rules based on the type and attributes provided
            </summary>
        </member>
        <member name="M:Grace.Validation.IAttributeValidationRuleProvider.ProvideRules(System.Type,System.Collections.Generic.IEnumerable{System.Attribute},System.Reflection.PropertyInfo,System.Collections.Generic.IEnumerable{System.Attribute})">
            <summary>
            Provide an enumeration of validation rules based on the attributes on a type
            </summary>
            <param name="objectType">type being validated</param>
            <param name="typeAttributes">attributes on the type</param>
            <param name="propertyInfo">property info that is tagged, can be null when the attribute is on the type</param>
            <param name="propertyInfoAttributes">attributes on the property, can be null</param>
            <returns>list of validation rules</returns>
        </member>
        <member name="T:Grace.Validation.IRuleExecutionContext">
            <summary>
            Non Generic rule execution context
            </summary>
        </member>
        <member name="M:Grace.Validation.IRuleExecutionContext.AddValidationPart(Grace.Validation.IValidationRuleResultPart)">
            <summary>
            Add a validation part to the rule
            </summary>
            <param name="part">validation part</param>
        </member>
        <member name="M:Grace.Validation.IRuleExecutionContext.AddRequired(System.String,System.String)">
            <summary>
            Adds required message
            </summary>
            <param name="partName">part that is required</param>
            <param name="message">required message</param>
        </member>
        <member name="M:Grace.Validation.IRuleExecutionContext.AddError(System.String,System.String)">
            <summary>
            Adds an error message to the context
            </summary>
            <param name="partName">part name that is invalid</param>
            <param name="message">error message</param>
        </member>
        <member name="M:Grace.Validation.IRuleExecutionContext.AddWarning(System.String,System.String)">
            <summary>
            Add a warning message
            </summary>
            <param name="partName">part name that has warning</param>
            <param name="message">warning message</param>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext.State">
            <summary>
            Validation state for rule execution
            </summary>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext.Message">
            <summary>
            Validation message
            </summary>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext.ValidationObject">
            <summary>
            Object being validated
            </summary>
        </member>
        <member name="T:Grace.Validation.IRuleExecutionContext`1">
            <summary>
            Hold the information for rule execution
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Grace.Validation.IRuleExecutionContext`1.AddValidationPart(Grace.Validation.IValidationRuleResultPart)">
            <summary>
            
            </summary>
            <param name="part"></param>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext`1.State">
            <summary>
            Current state
            </summary>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext`1.Message">
            <summary>
            Message for rule
            </summary>
        </member>
        <member name="P:Grace.Validation.IRuleExecutionContext`1.ValidationObject">
            <summary>
            Object to validate
            </summary>
        </member>
        <member name="T:Grace.Validation.ISyncValidationRule">
            <summary>
            Represents a standard validation rule that runs synchronously 
            </summary>
        </member>
        <member name="M:Grace.Validation.ISyncValidationRule.Validate(Grace.Validation.IRuleExecutionContext)">
            <summary>
            Validate an object
            </summary>
            <param name="ruleExecutionContext">rule execution context</param>
        </member>
        <member name="T:Grace.Validation.IValidationRuleProvider">
            <summary>
            classes thar implement this interface can provide validation rules for a type
            </summary>
        </member>
        <member name="M:Grace.Validation.IValidationRuleProvider.ProvideRules(System.Type,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            
            </summary>
            <param name="objectType"></param>
            <param name="standards"></param>
            <returns></returns>
        </member>
        <member name="T:Grace.Validation.IValidationRuleResult">
            <summary>
            Validation result for rule
            </summary>
        </member>
        <member name="M:Grace.Validation.IValidationRuleResult.ResultParts">
            <summary>
            Validation rule parts
            </summary>
            <returns></returns>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.Namespace">
            <summary>
            Namspace the rule exists in
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.RuleName">
            <summary>
            Rule name
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.ValidationObject">
            <summary>
            Object being validated
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.DisplayName">
            <summary>
            Rule display name
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.State">
            <summary>
            Validation state
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.Message">
            <summary>
            Validation message
            </summary>
        </member>
        <member name="P:Grace.Validation.IValidationRuleResult.RootPropertyPath">
            <summary>
            Root property path
            </summary>
        </member>
        <member name="T:Grace.Validation.ValidationState">
            <summary>
            Represents the validation state for an object or property
            </summary>
        </member>
        <member name="F:Grace.Validation.ValidationState.Valid">
            <summary>
            Valid
            </summary>
        </member>
        <member name="F:Grace.Validation.ValidationState.ValidWithWarning">
            <summary>
            Valid but with a warning
            </summary>
        </member>
        <member name="F:Grace.Validation.ValidationState.Invalid">
            <summary>
            Invalid
            </summary>
        </member>
        <member name="F:Grace.Validation.ValidationState.InvalidRequired">
            <summary>
            Invalid because it's required and empty
            </summary>
        </member>
    </members>
</doc>
